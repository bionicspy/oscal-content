{
  "catalog": {
    "uuid": "bcd7869e-6336-5582-8f2e-35000ef9a15a",
    "metadata": {
      "title": "CIS AlmaLinux OS 9 Benchmark - Level 2 - Server",
      "last-modified": "2024-06-24T15:29:34.000000-00:00",
      "version": "2.0.0",
      "oscal-version": "1.1.2",
      "revisions": [],
      "props": [
        {
          "name": "keywords",
          "value": "Assessment, assessment plan, assurance, availability, computer security, confidentiality, control, control assessment, cybersecurity, information security, information system, integrity, personally identifiable information, OSCAL, Open Security Controls Assessment Language, Privacy Act, privacy controls, privacy functions, privacy requirements, Risk Management Framework, security controls, security functions, security requirements, system, system security"
        }
      ],
      "links": [
        {
          "href": "#cbbde88b-e14e-40c2-8a1a-c96a4718f0b5",
          "rel": "alternate"
        },
        {
          "href": "#9f6eafb6-d1c4-4df3-8a62-cfb0de5cc517",
          "rel": "canonical"
        },
        {
          "href": "#a7e5c594-1c94-47e3-bfb4-6977dcc704a1",
          "rel": "excel"
        }
      ],
      "roles": [
        {
          "id": "creator",
          "title": "Document creator"
        },
        {
          "id": "contact",
          "title": "Contact"
        }
      ],
      "parties": [
        {
          "uuid": "d12ec12b-41f3-436c-b84c-c9909ee0bf2c",
          "type": "organization",
          "name": "Center for Internet Security, Inc.",
          "email-addresses": [
            "learn@cisecurity.org"
          ],
          "addresses": [
            {
              "addr-lines": [
                "Center for Internet Security, Inc.",
                "31 Tech Valley Drive"
              ],
              "city": "East Greenbush",
              "state": "NY",
              "postal-code": "12061"
            }
          ]
        }
      ],
      "responsible-parties": [
        {
          "role-id": "creator",
          "party-uuids": [
            "d12ec12b-41f3-436c-b84c-c9909ee0bf2c"
          ]
        },
        {
          "role-id": "contact",
          "party-uuids": [
            "d12ec12b-41f3-436c-b84c-c9909ee0bf2c"
          ]
        }
      ]
    },
    "groups": [
      {
        "id": "section-1",
        "title": "Initial Setup",
        "props": [
          {
            "name": "label",
            "value": "1"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-1-1",
            "title": "Filesystem",
            "props": [
              {
                "name": "label",
                "value": "1.1"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-1-1-1",
                "title": "Configure Filesystem Kernel Modules",
                "props": [
                  {
                    "name": "label",
                    "value": "1.1.1"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-1.1.1.6",
                    "title": "Ensure squashfs kernel module is not available",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.1.6"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-1.1.1.6_statement",
                        "prose": "The `squashfs` filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A `squashfs` image can be used without having to first decompress the image."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-1.1.1.6_assessment-objective",
                        "prose": "Rationale: Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.\nImpact: As Snap packages utilize `squashfs` as a compressed filesystem, disabling `squashfs` will cause Snap packages to fail.\n\n`Snap` application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store (\"App store\"), can be obtained from any source and can be therefore used for upstream software deployment."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-1.1.1.6_guidance",
                        "prose": "Run the following script to unload and disable the `udf` module:\n\n**- IF -** the `squashfs` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install squashfs /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist squashfs` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r squashfs 2>/dev/null; rmmod squashfs 2>/dev/null` to remove `squashfs` from the kernel\n\n**- IF -** the `squashfs` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"squashfs\" # set module name\n l_mod_type=\"fs\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-1.1.1.6_assessment-method",
                        "prose": "Run the following script to verify:\n\n**- IF -** the `squashfs` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `squashfs` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"squashfs\" # set module name\n l_mod_type=\"fs\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```\n\n**Note:** On operating systems where `squashfs` is pre-build into the kernel:\n- This is considered an acceptable \"passing\" state\n- The kernel **should not** be re-compiled to remove `squashfs`\n- This audit will return a passing state with \"module: \"squashfs\" doesn't exist in ...\"",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-1.1.1.7",
                    "title": "Ensure udf kernel module is not available",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.1.7"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-1.1.1.7_statement",
                        "prose": "The `udf` filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-1.1.1.7_assessment-objective",
                        "prose": "Rationale: Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it.\nImpact: Microsoft Azure requires the usage of `udf`. \n\n`udf` **should not** be disabled on systems run on Microsoft Azure."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-1.1.1.7_guidance",
                        "prose": "Run the following script to unload and disable the `udf` module:\n\n**- IF -** the `udf` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install udf /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist udf` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r udf 2>/dev/null; rmmod udf 2>/dev/null` to remove `udf` from the kernel\n\n**- IF -** the `udf` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"udf\" # set module name\n l_mod_type=\"fs\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-1.1.1.7_assessment-method",
                        "prose": "Run the following script to verify:\n\n**- IF -** the `udf` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `udf` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"udf\" # set module name\n l_mod_type=\"fs\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b'\"$l_mod_name\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name/-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name/-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-1-1-2",
                "title": "Configure Filesystem Partitions",
                "props": [
                  {
                    "name": "label",
                    "value": "1.1.2"
                  }
                ],
                "controls": [],
                "groups": [
                  {
                    "id": "section-1-1-2-1",
                    "title": "Configure /tmp",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.1"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-2",
                    "title": "Configure /dev/shm",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.2"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-3",
                    "title": "Configure /home",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.3"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-1.1.2.3.1",
                        "title": "Ensure separate partition exists for /home",
                        "props": [
                          {
                            "name": "label",
                            "value": "1.1.2.3.1"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-1.1.2.3.1_statement",
                            "prose": "The `/home` directory is used to support disk storage needs of local users."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-1.1.2.3.1_assessment-objective",
                            "prose": "Rationale: The default installation only creates a single `/` partition. Since the `/home` directory contains user generated data, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to `/home` and impact all local users.\n\nConfiguring `/home` as its own file system allows an administrator to set additional mount options such as `noexec/nosuid/nodev`. These options limit an attacker's ability to create exploits on the system. In the case of `/home` options such as `usrquota/grpquota` may be considered to limit the impact that users can have on each other with regards to disk resource exhaustion. Other options allow for specific behavior. See `man mount` for exact details regarding filesystem-independent and filesystem-specific options.\n\nAs `/home` contains user data, care should be taken to ensure the security and integrity of the data and mount point.\nImpact: Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-1.1.2.3.1_guidance",
                            "prose": "For new installations, during installation create a custom partition setup and specify a separate partition for `/home`.\n\nFor systems that were previously installed, create a new partition and configure `/etc/fstab` as appropriate."
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-1.1.2.3.1_assessment-method",
                            "prose": "Run the following command and verify output shows `/home` is mounted:\n\n```\n# findmnt -kn /home\n\n/home /dev/sdb ext4 rw,nosuid,nodev,noexec,relatime,seclabel\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-4",
                    "title": "Configure /var",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.4"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-1.1.2.4.1",
                        "title": "Ensure separate partition exists for /var",
                        "props": [
                          {
                            "name": "label",
                            "value": "1.1.2.4.1"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-1.1.2.4.1_statement",
                            "prose": "The `/var` directory is used by daemons and other system services to temporarily store dynamic data. Some directories created by these processes may be world-writable."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-1.1.2.4.1_assessment-objective",
                            "prose": "Rationale: The reasoning for mounting `/var` on a separate partition is as follows.\n\nThe default installation only creates a single `/` partition. Since the `/var` directory may contain world writable files and directories, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system. In addition, other operations on the system could fill up the disk unrelated to `/var` and cause unintended behavior across the system as the disk is full. See `man auditd.conf` for details.\n\nConfiguring `/var` as its own file system allows an administrator to set additional mount options such as `noexec/nosuid/nodev`. These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See `man mount` for exact details regarding filesystem-independent and filesystem-specific options.\n\nAn example of exploiting `/var` may be an attacker establishing a hard-link to a system `setuid` program and waiting for it to be updated. Once the program is updated, the hard-link can be broken and the attacker would have their own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw.\nImpact: Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-1.1.2.4.1_guidance",
                            "prose": "For new installations, during installation create a custom partition setup and specify a separate partition for `/var`.\n\nFor systems that were previously installed, create a new partition and configure `/etc/fstab` as appropriate."
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-1.1.2.4.1_assessment-method",
                            "prose": "Run the following command and verify output shows `/var` is mounted.\n\n_Example:_\n\n```\n# findmnt -kn /var\n\n/var /dev/sdb ext4 rw,nosuid,nodev,noexec,relatime,seclabel\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-5",
                    "title": "Configure /var/tmp",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.5"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-1.1.2.5.1",
                        "title": "Ensure separate partition exists for /var/tmp",
                        "props": [
                          {
                            "name": "label",
                            "value": "1.1.2.5.1"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-1.1.2.5.1_statement",
                            "prose": "The `/var/tmp` directory is a world-writable directory used for temporary storage by all users and some applications. Temporary files residing in `/var/tmp` are to be preserved between reboots."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-1.1.2.5.1_assessment-objective",
                            "prose": "Rationale: The default installation only creates a single `/` partition. Since the `/var/tmp` directory is world-writable, there is a risk of resource exhaustion. In addition, other operations on the system could fill up the disk unrelated to `/var/tmp` and cause potential disruption to daemons as the disk is full.\n\nConfiguring `/var/tmp` as its own file system allows an administrator to set additional mount options such as `noexec/nosuid/nodev`. These options limit an attacker's ability to create exploits on the system.\nImpact: Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-1.1.2.5.1_guidance",
                            "prose": "For new installations, during installation create a custom partition setup and specify a separate partition for `/var/tmp`.\n\nFor systems that were previously installed, create a new partition and configure `/etc/fstab` as appropriate."
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-1.1.2.5.1_assessment-method",
                            "prose": "Run the following command and verify output shows `/var/tmp` is mounted.\n\n_Example:_\n\n```\n# findmnt -kn /var/tmp\n\n/var/tmp /dev/sdb ext4 rw,nosuid,nodev,noexec,relatime,seclabel\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-6",
                    "title": "Configure /var/log",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.6"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-1.1.2.6.1",
                        "title": "Ensure separate partition exists for /var/log",
                        "props": [
                          {
                            "name": "label",
                            "value": "1.1.2.6.1"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-1.1.2.6.1_statement",
                            "prose": "The `/var/log` directory is used by system services to store log data."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-1.1.2.6.1_assessment-objective",
                            "prose": "Rationale: The default installation only creates a single `/` partition. Since the `/var/log` directory contains log files which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole.\n\nConfiguring `/var/log` as its own file system allows an administrator to set additional mount options such as `noexec/nosuid/nodev`. These options limit an attackers ability to create exploits on the system. Other options allow for specific behavior. See `man mount` for exact details regarding filesystem-independent and filesystem-specific options.\n\nAs `/var/log` contains log files, care should be taken to ensure the security and integrity of the data and mount point.\nImpact: Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing, or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-1.1.2.6.1_guidance",
                            "prose": "For new installations, during installation create a custom partition setup and specify a separate partition for `/var/log` .\n\nFor systems that were previously installed, create a new partition and configure `/etc/fstab` as appropriate."
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-1.1.2.6.1_assessment-method",
                            "prose": "Run the following command and verify output shows `/var/log` is mounted:\n\n```\n# findmnt -kn /var/log\n\n/var/log /dev/sdb ext4 rw,nosuid,nodev,noexec,relatime,seclabel\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  },
                  {
                    "id": "section-1-1-2-7",
                    "title": "Configure /var/log/audit",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.1.2.7"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-1.1.2.7.1",
                        "title": "Ensure separate partition exists for /var/log/audit",
                        "props": [
                          {
                            "name": "label",
                            "value": "1.1.2.7.1"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-1.1.2.7.1_statement",
                            "prose": "The auditing daemon, `auditd`, stores log data in the `/var/log/audit` directory."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-1.1.2.7.1_assessment-objective",
                            "prose": "Rationale: The default installation only creates a single `/` partition. Since the `/var/log/audit` directory contains the `audit.log` file which can grow quite large, there is a risk of resource exhaustion. It will essentially have the whole disk available to fill up and impact the system as a whole. In addition, other operations on the system could fill up the disk unrelated to `/var/log/audit` and cause `auditd` to trigger its `space_left_action` as the disk is full. See `man auditd.conf` for details.\n\nConfiguring `/var/log/audit` as its own file system allows an administrator to set additional mount options such as `noexec/nosuid/nodev`. These options limit an attacker's ability to create exploits on the system. Other options allow for specific behavior. See `man mount` for exact details regarding filesystem-independent and filesystem-specific options.\n\nAs `/var/log/audit` contains audit logs, care should be taken to ensure the security and integrity of the data and mount point.\nImpact: Resizing filesystems is a common activity in cloud-hosted servers. Separate filesystem partitions may prevent successful resizing or may require the installation of additional tools solely for the purpose of resizing operations. The use of these additional tools may introduce their own security considerations."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-1.1.2.7.1_guidance",
                            "prose": "For new installations, during installation create a custom partition setup and specify a separate partition for `/var/log/audit`.\n\nFor systems that were previously installed, create a new partition and configure `/etc/fstab` as appropriate."
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-1.1.2.7.1_assessment-method",
                            "prose": "Run the following command and verify output shows `/var/log/audit` is mounted:\n\n```\n# findmnt -kn /var/log/audit\n\n/var/log/audit /dev/sdb ext4 rw,nosuid,nodev,noexec,relatime,seclabel\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  }
                ]
              }
            ]
          },
          {
            "id": "section-1-2",
            "title": "Package Management",
            "props": [
              {
                "name": "label",
                "value": "1.2"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-1-2-1",
                "title": "Configure Package Repositories",
                "props": [
                  {
                    "name": "label",
                    "value": "1.2.1"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-1.2.1.3",
                    "title": "Ensure repo_gpgcheck is globally activated",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.2.1.3"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-1.2.1.3_statement",
                        "prose": "The `repo_gpgcheck` option, found in the main section of the `/etc/dnf/dnf.conf` and individual `/etc/yum.repos.d/*` files, will perform a GPG signature check on the repodata."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-1.2.1.3_assessment-objective",
                        "prose": "Rationale: It is important to ensure that the repository data signature is always checked prior to installation to ensure that the software is not tampered with in any way.\nImpact: Not all repositories, notably RedHat, support `repo_gpgcheck`. Take care to set this value to false (default) for particular repositories that do not support it. If enabled on repositories that do not support `repo_gpgcheck` installation of packages will fail.\n\nResearch is required by the user to determine which repositories is configured on the local system and, from that list, which support `repo_gpgcheck`."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-1.2.1.3_guidance",
                        "prose": "**Global configuration**\n\nEdit `/etc/dnf/dnf.conf` and set `repo_gpgcheck=1` in the `[main]` section.\n\n_Example:_\n\n```\n[main]\nrepo_gpgcheck=1\n```\n\n**Per repository configuration**\n\nFirst check that the particular repository support GPG checking on the repodata.\n\nEdit any failing files in `/etc/yum.repos.d/*` and set all instances starting with `repo_gpgcheck` to `1`."
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-1.2.1.3_assessment-method",
                        "prose": "**Global configuration**\n\nRun the following command:\n\n```\ngrep ^repo_gpgcheck /etc/dnf/dnf.conf\n```\n\nVerify that `repo_gpgcheck` is set to `1`\n\n**Per repository configuration**\n\nConfiguration in `/etc/yum.repos.d/` takes precedence over the global configuration.\n\nAs an example, to list all the configured repositories, excluding \"fedoraproject.org\", that specifically disables `repo_gpgcheck`, run the following command:\n\n```\n# REPO_URL=\"fedoraproject.org\"\n# for repo in $(grep -l \"repo_gpgcheck=0\" /etc/yum.repos.d/* ); do\n if ! grep \"${REPO_URL}\" \"${repo}\" &>/dev/null; then\n echo \"${repo}\"\n fi\ndone\n```\n\nPer the research that was done on which repositories does not support `repo_gpgcheck`, change the `REPO_URL` variable and run the test.",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-1-2-2",
                "title": "Configure Package Updates",
                "props": [
                  {
                    "name": "label",
                    "value": "1.2.2"
                  }
                ],
                "controls": [],
                "groups": []
              }
            ]
          },
          {
            "id": "section-1-3",
            "title": "Mandatory Access Control",
            "props": [
              {
                "name": "label",
                "value": "1.3"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-1-3-1",
                "title": "Configure SELinux",
                "props": [
                  {
                    "name": "label",
                    "value": "1.3.1"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-1.3.1.5",
                    "title": "Ensure the SELinux mode is enforcing",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.3.1.5"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-1.3.1.5_statement",
                        "prose": "SELinux can run in one of three modes: disabled, permissive, or enforcing:\n- `Enforcing` - Is the default, and recommended, mode of operation; in enforcing mode SELinux operates normally, enforcing the loaded security policy on the entire system.\n- `Permissive` - The system acts as if SELinux is enforcing the loaded security policy, including labeling objects and emitting access denial entries in the logs, but it does not actually deny any operations. While not recommended for production systems, permissive mode can be helpful for SELinux policy development.\n- `Disabled` - Is strongly discouraged; not only does the system avoid enforcing the SELinux policy, it also avoids labeling any persistent objects such as files, making it difficult to enable SELinux in the future\n\n**Note:** You can set individual domains to permissive mode while the system runs in enforcing mode. For example, to make the httpd_t domain permissive:\n```\n# semanage permissive -a httpd_t"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-1.3.1.5_assessment-objective",
                        "prose": "Rationale: Running SELinux in disabled mode the system not only avoids enforcing the SELinux policy, it also avoids labeling any persistent objects such as files, making it difficult to enable SELinux in the future. \n\nRunning SELinux in Permissive mode, though helpful for developing SELinux policy, only logs access denial entries, but does not deny any operations.\nImpact: Running SELinux in Enforcing mode may block intended access to files or processes if the SELinux policy is not correctly configured. If this occurs, review the system logs for details and update labels or policy as appropriate."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-1.3.1.5_guidance",
                        "prose": "Run the following command to set SELinux's running mode:\n\n```\n# setenforce 1\n```\n\nEdit the `/etc/selinux/config` file to set the SELINUX parameter:\n\nFor Enforcing mode:\n\n```\nSELINUX=enforcing\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-1.3.1.5_assessment-method",
                        "prose": "Run the following command to verify SELinux's current mode:\n```\n# getenforce\n\nEnforcing\n```\n\nRun the following command to verify SELinux's configured mode:\n```\n# grep -i SELINUX=enforcing /etc/selinux/config\n\nSELINUX=enforcing\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-1.3.1.6",
                    "title": "Ensure no unconfined services exist",
                    "props": [
                      {
                        "name": "label",
                        "value": "1.3.1.6"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-1.3.1.6_statement",
                        "prose": "Unconfined processes run in unconfined domains"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-1.3.1.6_assessment-objective",
                        "prose": "Rationale: For unconfined processes, SELinux policy rules are applied, but policy rules exist that allow processes running in unconfined domains almost all access. Processes running in unconfined domains fall back to using DAC rules exclusively. If an unconfined process is compromised, SELinux does not prevent an attacker from gaining access to system resources and data, but of course, DAC rules are still used. SELinux is a security enhancement on top of DAC rules \u2013 it does not replace them\nImpact: Confining a service that inherently requires unconfined access to function may disrupt its intended operations. This restriction may lead to downtime, degraded performance, or loss in functionality. It is crucial to analyze and adjust SELinux policies in accordance with site security policies and operational requirements."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-1.3.1.6_guidance",
                        "prose": "Investigate any unconfined processes found during the audit action. If necessary create a customize SELinux policy to allow necessary actions for the service.\n\n**Warning:** Knowledge about creating and configuring SELinux policies is needed. A Basic example on how to create a policy is included below.\n\n1. Identify the unconfined service: determine the name and process of the service\n\n2. Identify the functionality: determine if the functionality is required for operations\n\n3. Create or add to the custom allow list in the SELinux policy configuration\n\n_Example SELinux policy configuration: service_allowlist_policy.te_\n\n```\n# Example SELinux policy configuration for allowing access to specific actions and resources for a service\n\nmodule my_service 1.0;\n\nrequire {\n type my_service_t;\n type system_resource_t;\n class file { read write execute };\n class dir { read write add_name };\n class tcp_socket name_connect;\n}\n\nallow my_service_t system_resource_t:file { read write execute }; # Allow my_service_t to read, write, and execute files with the system_resource_t context\n\nallow my_service_t system_resource_t:dir { read write add_name }; # Allow my_service_t to read and write to directories with the system_resource_t context\n\nallow my_service_t system_resource_t:tcp_socket name_connect; # Allow my_service_t to establish TCP connections\n```\n\n4. Compile the policy\n```\n# checkmodule -M -, -o service_allowlist_policy.mod service_allowlist_policy.te\n```\n\n5. Create the package\n```\n# semodule_package -o service_allowlist_policy.pp -m service_allowlist_policy.mod\n```\n\n6. Load the policy\n```\n# semodule -i service_allowlist_policy.pp\n```\n\n7. Apply the policy to the service\n```\n# chcon -t se service_allowlist_policy /path/to/service_binary\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-1.3.1.6_assessment-method",
                        "prose": "Run the following command and verify no output is produced:\n\n```\n# ps -eZ | grep unconfined_service_t\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              }
            ]
          },
          {
            "id": "section-1-4",
            "title": "Configure Bootloader",
            "props": [
              {
                "name": "label",
                "value": "1.4"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-1-5",
            "title": "Configure Additional Process Hardening",
            "props": [
              {
                "name": "label",
                "value": "1.5"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-1-6",
            "title": "Configure system wide crypto policy",
            "props": [
              {
                "name": "label",
                "value": "1.6"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-1-7",
            "title": "Configure Command Line Warning Banners",
            "props": [
              {
                "name": "label",
                "value": "1.7"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-1-8",
            "title": "Configure GNOME Display Manager",
            "props": [
              {
                "name": "label",
                "value": "1.8"
              }
            ],
            "controls": [
              {
                "id": "cis-1.8.1",
                "title": "Ensure GNOME Display Manager is removed",
                "props": [
                  {
                    "name": "label",
                    "value": "1.8.1"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-1.8.1_statement",
                    "prose": "The GNOME Display Manager (GDM) is a program that manages graphical display servers and handles graphical user logins."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-1.8.1_assessment-objective",
                    "prose": "Rationale: If a Graphical User Interface (GUI) is not required, it should be removed to reduce the attack surface of the system.\nImpact: Removing the GNOME Display manager will remove the Graphical User Interface (GUI) from the system."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-1.8.1_guidance",
                    "prose": "Run the following command to remove the `gdm` package\n\n```\n# dnf remove gdm\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-1.8.1_assessment-method",
                    "prose": "Run the following command and verify the output:\n\n```\n# rpm -q gdm\n\npackage gdm is not installed\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          }
        ]
      },
      {
        "id": "section-2",
        "title": "Services",
        "props": [
          {
            "name": "label",
            "value": "2"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-2-1",
            "title": "Configure Server Services",
            "props": [
              {
                "name": "label",
                "value": "2.1"
              }
            ],
            "controls": [
              {
                "id": "cis-2.1.20",
                "title": "Ensure X window server services are not in use",
                "props": [
                  {
                    "name": "label",
                    "value": "2.1.20"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-2.1.20_statement",
                    "prose": "The X Window System provides a Graphical User Interface (GUI) where users can have multiple windows in which to run programs and various add on. The X Windows system is typically used on workstations where users login, but not on servers where users typically do not login."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-2.1.20_assessment-objective",
                    "prose": "Rationale: Unless your organization specifically requires graphical login access via X Windows, remove it to reduce the potential attack surface.\nImpact: If a Graphical Desktop Manager (GDM) is in use on the system, there may be a dependency on the `xorg-x11-server-common` package. If the GDM is required and approved by local site policy, the package should **not** be removed.\n\nMany Linux systems run applications which require a Java runtime. Some Linux Java packages have a dependency on specific X Windows xorg-x11-fonts. One workaround to avoid this dependency is to use the \"headless\" Java packages for your specific Java runtime."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-2.1.20_guidance",
                    "prose": "**- IF -** a Graphical Desktop Manager or X-Windows server is not required and approved by local site policy:\n\nRun the following command to remove the X Windows Server packages:\n\n```\n# dnf remove xorg-x11-server-common\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-2.1.20_assessment-method",
                    "prose": "**- IF -** a Graphical Desktop Manager or X-Windows server is not required and approved by local site policy:\n\nRun the following command to Verify X Windows Server is not installed.\n\n```\n# rpm -q xorg-x11-server-common\n\npackage xorg-x11-server-common is not installed\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          },
          {
            "id": "section-2-2",
            "title": "Configure Client Services",
            "props": [
              {
                "name": "label",
                "value": "2.2"
              }
            ],
            "controls": [
              {
                "id": "cis-2.2.2",
                "title": "Ensure ldap client is not installed",
                "props": [
                  {
                    "name": "label",
                    "value": "2.2.2"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-2.2.2_statement",
                    "prose": "The Lightweight Directory Access Protocol (LDAP) was introduced as a replacement for NIS/YP. It is a service that provides a method for looking up information from a central database."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-2.2.2_assessment-objective",
                    "prose": "Rationale: If the system will not need to act as an LDAP client, it is recommended that the software be removed to reduce the potential attack surface.\nImpact: Removing the LDAP client will prevent or inhibit using LDAP for authentication in your environment."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-2.2.2_guidance",
                    "prose": "Run the following command to remove the `openldap-clients` package:\n\n```\n# dnf remove openldap-clients\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-2.2.2_assessment-method",
                    "prose": "Run the following command to verify that the `openldap-clients` package is not installed:\n\n```\n# rpm -q openldap-clients\n\npackage openldap-clients is not installed\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          },
          {
            "id": "section-2-3",
            "title": "Configure Time Synchronization",
            "props": [
              {
                "name": "label",
                "value": "2.3"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-2-4",
            "title": "Job Schedulers",
            "props": [
              {
                "name": "label",
                "value": "2.4"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-2-4-1",
                "title": "Configure cron",
                "props": [
                  {
                    "name": "label",
                    "value": "2.4.1"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-2-4-2",
                "title": "Configure at",
                "props": [
                  {
                    "name": "label",
                    "value": "2.4.2"
                  }
                ],
                "controls": [],
                "groups": []
              }
            ]
          }
        ]
      },
      {
        "id": "section-3",
        "title": "Network",
        "props": [
          {
            "name": "label",
            "value": "3"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-3-1",
            "title": "Configure Network Devices",
            "props": [
              {
                "name": "label",
                "value": "3.1"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-3-2",
            "title": "Configure Network Kernel Modules",
            "props": [
              {
                "name": "label",
                "value": "3.2"
              }
            ],
            "controls": [
              {
                "id": "cis-3.2.1",
                "title": "Ensure dccp kernel module is not available",
                "props": [
                  {
                    "name": "label",
                    "value": "3.2.1"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-3.2.1_statement",
                    "prose": "The Datagram Congestion Control Protocol (DCCP) is a transport layer protocol that supports streaming media and telephony. DCCP provides a way to gain access to congestion control, without having to do it at the application layer, but does not provide in-sequence delivery."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-3.2.1_assessment-objective",
                    "prose": "Rationale: **- IF -** the protocol is not required, it is recommended that the drivers not be installed to reduce the potential attack surface."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-3.2.1_guidance",
                    "prose": "Run the following script to unload and disable the `dccp` module:\n\n**- IF -** the `dccp` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install dccp /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist dccp` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r dccp 2>/dev/null; rmmod dccp 2>/dev/null` to remove `dccp` from the kernel\n\n**- IF -** the `dccp` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"dccp\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-3.2.1_assessment-method",
                    "prose": "Run the following script to verify:\n\n**- IF -** the `dccp` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `dccp` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"dccp\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              },
              {
                "id": "cis-3.2.2",
                "title": "Ensure tipc kernel module is not available",
                "props": [
                  {
                    "name": "label",
                    "value": "3.2.2"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-3.2.2_statement",
                    "prose": "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communication between cluster nodes."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-3.2.2_assessment-objective",
                    "prose": "Rationale: **- IF -** the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-3.2.2_guidance",
                    "prose": "Run the following script to unload and disable the `tipc` module:\n\n**- IF -** the `tipc` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install tipc /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist tipc` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r tipc 2>/dev/null; rmmod tipc 2>/dev/null` to remove `tipc` from the kernel\n\n**- IF -** the `tipc` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"tipc\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-3.2.2_assessment-method",
                    "prose": "Run the following script to verify:\n\n**- IF -** the `tipc` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `tipc` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"tipc\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              },
              {
                "id": "cis-3.2.3",
                "title": "Ensure rds kernel module is not available",
                "props": [
                  {
                    "name": "label",
                    "value": "3.2.3"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-3.2.3_statement",
                    "prose": "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide low-latency, high-bandwidth communications between cluster nodes. It was developed by the Oracle Corporation."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-3.2.3_assessment-objective",
                    "prose": "Rationale: **- IF -** the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-3.2.3_guidance",
                    "prose": "Run the following script to unload and disable the `rds` module:\n\n**- IF -** the `rds` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install rds /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist rds` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r rds 2>/dev/null; rmmod rds 2>/dev/null` to remove `rds` from the kernel\n\n**- IF -** the `rds` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"rds\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-3.2.3_assessment-method",
                    "prose": "Run the following script to verify:\n\n**- IF -** the `rds` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `rds` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"rds\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              },
              {
                "id": "cis-3.2.4",
                "title": "Ensure sctp kernel module is not available",
                "props": [
                  {
                    "name": "label",
                    "value": "3.2.4"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-3.2.4_statement",
                    "prose": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol used to support message oriented communication, with several streams of messages in one connection. It serves a similar function as TCP and UDP, incorporating features of both. It is message-oriented like UDP, and ensures reliable in-sequence transport of messages with congestion control like TCP."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-3.2.4_assessment-objective",
                    "prose": "Rationale: **- IF -** the protocol is not being used, it is recommended that kernel module not be loaded, disabling the service to reduce the potential attack surface."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-3.2.4_guidance",
                    "prose": "Run the following script to unload and disable the `sctp` module:\n\n**- IF -** the `sctp` kernel module is available in ANY installed kernel:\n - Create a file ending in `.conf` with `install sctp /bin/false` in the `/etc/modprobe.d/` directory\n - Create a file ending in `.conf` with `blacklist sctp` in the `/etc/modprobe.d/` directory\n - Run `modprobe -r sctp 2>/dev/null; rmmod sctp 2>/dev/null` to remove `sctp` from the kernel\n\n**- IF -** the `sctp` kernel module is not available on the system, or pre-compiled into the kernel, no remediation is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n unset a_output2; l_output3=\"\" l_dl=\"\" # unset arrays and clear variables\n l_mod_name=\"sctp\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_fix()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output2+=(\" - unloading kernel module: \\\"$l_mod_name\\\"\")\n modprobe -r \"$l_mod_name\" 2>/dev/null; rmmod \"$l_mod_name\" 2>/dev/null\n fi\n if ! grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - setting kernel module: \\\"$l_mod_name\\\" to \\\"/bin/false\\\"\")\n printf '%s\\n' \"install $l_mod_name /bin/false\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n if ! grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output2+=(\" - denylisting kernel module: \\\"$l_mod_name\\\"\")\n printf '%s\\n' \"blacklist $l_mod_name\" >> /etc/modprobe.d/\"$l_mod_name\".conf\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_fix\n else\n echo -e \" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\"\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n [ \"${#a_output2[@]}\" -gt 0 ] && printf '%s\\n' \"${a_output2[@]}\"\n echo -e \"\\n - remediation of kernel module: \\\"$l_mod_name\\\" complete\\n\"\n}\n```"
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-3.2.4_assessment-method",
                    "prose": "Run the following script to verify:\n\n**- IF -** the `sctp` kernel module is available in ANY installed kernel, verify:\n- An entry including `/bin/true` or `/bin/false` exists in a file within the `/etc/modprobe.d/` directory\n- The module is deny listed in a file within the `/etc/modprobe.d/` directory\n- The module is not loaded in the running kernel\n\n**- IF -** the `sctp` kernel module is not available on the system, or pre-compiled into the kernel, no additional configuration is necessary\n\n```\n#!/usr/bin/env bash\n\n{\n l_output3=\"\" l_dl=\"\" # clear variables\n unset a_output; unset a_output2 # unset arrays\n l_mod_name=\"sctp\" # set module name\n l_mod_type=\"net\" # set module type\n l_mod_path=\"$(readlink -f /lib/modules/**/kernel/$l_mod_type | sort -u)\"\n f_module_chk()\n {\n l_dl=\"y\" # Set to ignore duplicate checks\n a_showconfig=() # Create array with modprobe output\n while IFS= read -r l_showconfig; do\n a_showconfig+=(\"$l_showconfig\")\n done < <(modprobe --showconfig | grep -P -- '\\b(install|blacklist)\\h+'\"${l_mod_name//-/_}\"'\\b')\n if ! lsmod | grep \"$l_mod_name\" &> /dev/null; then # Check if the module is currently loaded\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loaded\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loaded\")\n fi\n if grep -Pq -- '\\binstall\\h+'\"${l_mod_name//-/_}\"'\\h+\\/bin\\/(true|false)\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is not loadable\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is loadable\")\n fi\n if grep -Pq -- '\\bblacklist\\h+'\"${l_mod_name//-/_}\"'\\b' <<< \"${a_showconfig[*]}\"; then\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" is deny listed\")\n else\n a_output2+=(\" - kernel module: \\\"$l_mod_name\\\" is not deny listed\")\n fi\n }\n for l_mod_base_directory in $l_mod_path; do # Check if the module exists on the system\n if [ -d \"$l_mod_base_directory/${l_mod_name/-/\\/}\" ] && [ -n \"$(ls -A $l_mod_base_directory/${l_mod_name/-/\\/})\" ]; then\n l_output3=\"$l_output3\\n - \\\"$l_mod_base_directory\\\"\"\n [[ \"$l_mod_name\" =~ overlay ]] && l_mod_name=\"${l_mod_name::-2}\" \n [ \"$l_dl\" != \"y\" ] && f_module_chk\n else\n a_output+=(\" - kernel module: \\\"$l_mod_name\\\" doesn't exist in \\\"$l_mod_base_directory\\\"\")\n fi\n done\n [ -n \"$l_output3\" ] && echo -e \"\\n\\n -- INFO --\\n - module: \\\"$l_mod_name\\\" exists in:$l_output3\"\n if [ \"${#a_output2[@]}\" -le 0 ]; then\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** PASS **\" \"${a_output[@]}\"\n else\n printf '%s\\n' \"\" \"- Audit Result:\" \" ** FAIL **\" \" - Reason(s) for audit failure:\" \"${a_output2[@]}\"\n [ \"${#a_output[@]}\" -gt 0 ] && printf '%s\\n' \"- Correctly set:\" \"${a_output[@]}\"\n fi\n}\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          },
          {
            "id": "section-3-3",
            "title": "Configure Network Kernel Parameters",
            "props": [
              {
                "name": "label",
                "value": "3.3"
              }
            ],
            "controls": [],
            "groups": []
          }
        ]
      },
      {
        "id": "section-4",
        "title": "Host Based Firewall",
        "props": [
          {
            "name": "label",
            "value": "4"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-4-1",
            "title": "Configure a firewall utility",
            "props": [
              {
                "name": "label",
                "value": "4.1"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-4-2",
            "title": "Configure FirewallD",
            "props": [
              {
                "name": "label",
                "value": "4.2"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-4-3",
            "title": "Configure NFTables",
            "props": [
              {
                "name": "label",
                "value": "4.3"
              }
            ],
            "controls": [],
            "groups": []
          }
        ]
      },
      {
        "id": "section-5",
        "title": "Access Control",
        "props": [
          {
            "name": "label",
            "value": "5"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-5-1",
            "title": "Configure SSH Server",
            "props": [
              {
                "name": "label",
                "value": "5.1"
              }
            ],
            "controls": [
              {
                "id": "cis-5.1.10",
                "title": "Ensure sshd DisableForwarding is enabled",
                "props": [
                  {
                    "name": "label",
                    "value": "5.1.10"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-5.1.10_statement",
                    "prose": "The `DisableForwarding` parameter disables all forwarding features, including X11, ssh-agent(1), TCP and StreamLocal. This option overrides all other forwarding-related options and may simplify restricted configurations.\n- X11Forwarding provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections.\n- ssh-agent is a program to hold private keys used for public key authentication. Through use of environment variables the agent can be located and automatically used for authentication when logging in to other machines using ssh.\n- SSH port forwarding is a mechanism in SSH for tunneling application ports from the client to the server, or servers to clients. It can be used for adding encryption to legacy applications, going through firewalls, and some system administrators and IT professionals use it for opening backdoors into the internal network from their home machines."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-5.1.10_assessment-objective",
                    "prose": "Rationale: Disable X11 forwarding unless there is an operational requirement to use X11 applications directly. There is a small risk that the remote X11 servers of users who are logged in via SSH with X11 forwarding could be compromised by other users on the X11 server. Note that even if X11 forwarding is disabled, users can always install their own forwarders.\n\nanyone with root privilege on the the intermediate server can make free use of ssh-agent to authenticate them to other servers\n\nLeaving port forwarding enabled can expose the organization to security risks and backdoors. SSH connections are protected with strong encryption. This makes their contents invisible to most deployed network monitoring and traffic filtering solutions. This invisibility carries considerable risk potential if it is used for malicious purposes such as data exfiltration. Cybercriminals or malware could exploit SSH to hide their unauthorized communications, or to exfiltrate stolen data from the target network.\nImpact: SSH tunnels are widely used in many corporate environments. In some environments the applications themselves may have very limited native support for security. By utilizing tunneling, compliance with SOX, HIPAA, PCI-DSS, and other standards can be achieved without having to modify the applications."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-5.1.10_guidance",
                    "prose": "Edit the `/etc/ssh/sshd_config` file to set the `DisableForwarding` parameter to `yes` above any `Include` entry as follows:\n\n```\nDisableForwarding yes\n```\n\n**Note:** First occurrence of a option takes precedence. If Include locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in Include location."
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-5.1.10_assessment-method",
                    "prose": "Run the following command to verify `DisableForwarding` is set to `yes`:\n\n```\n# sshd -T | grep -i disableforwarding\n\ndisableforwarding yes\n```",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              },
              {
                "id": "cis-5.1.11",
                "title": "Ensure sshd GSSAPIAuthentication is disabled",
                "props": [
                  {
                    "name": "label",
                    "value": "5.1.11"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-5.1.11_statement",
                    "prose": "The `GSSAPIAuthentication` parameter specifies whether user authentication based on GSSAPI is allowed"
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-5.1.11_assessment-objective",
                    "prose": "Rationale: Allowing GSSAPI authentication through SSH exposes the system's GSSAPI to remote hosts, and should be disabled to reduce the attack surface of the system"
                  },
                  {
                    "name": "guidance",
                    "id": "cis-5.1.11_guidance",
                    "prose": "Edit the `/etc/ssh/sshd_config` file to set the `GSSAPIAuthentication` parameter to `no` above any `Include` and `Match` entries as follows:\n\n```\nGSSAPIAuthentication no\n```\n\n**Note:** First occurrence of an option takes precedence, `Match` set statements withstanding. If `Include` locations are enabled, used, and order of precedence is understood in your environment, the entry may be created in a file in `Include` location."
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-5.1.11_assessment-method",
                    "prose": "Run the following command to verify `GSSAPIAuthentication` is set to `no`:\n\n```\n# sshd -T | grep gssapiauthentication\n\ngssapiauthentication no\n```\n\n**- IF -** `Match` set statements are used in your environment, specify the connection parameters to use for the `-T` extended test mode and run the audit to verify the setting is not incorrectly configured in a match block\n\n_Example additional audit needed for a match block for the user `sshuser`:_\n\n```\n# sshd -T -C user=sshuser | grep gssapiauthentication\n```\n\n**Note:** If provided, any Match directives in the configuration file that would apply are applied before the configuration is written to standard output. The connection parameters are supplied as keyword=value pairs and may be supplied in any order, either with multiple `-C` options or as a comma-separated list. The keywords are `addr` (source address), `user` (user), `host` (resolved source host name), `laddr` (local address), `lport` (local port number), and `rdomain` (routing domain)",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          },
          {
            "id": "section-5-2",
            "title": "Configure privilege escalation",
            "props": [
              {
                "name": "label",
                "value": "5.2"
              }
            ],
            "controls": [
              {
                "id": "cis-5.2.4",
                "title": "Ensure users must provide password for escalation",
                "props": [
                  {
                    "name": "label",
                    "value": "5.2.4"
                  }
                ],
                "parts": [
                  {
                    "name": "statement",
                    "id": "cis-5.2.4_statement",
                    "prose": "The operating system must be configured so that users must provide a password for privilege escalation."
                  },
                  {
                    "name": "assessment-objective",
                    "id": "cis-5.2.4_assessment-objective",
                    "prose": "Rationale: Without re-authentication, users may access resources or perform tasks for which they do not have authorization. \n\nWhen operating systems provide the capability to escalate a functional capability, it is critical the user re-authenticate.\nImpact: This will prevent automated processes from being able to elevate privileges."
                  },
                  {
                    "name": "guidance",
                    "id": "cis-5.2.4_guidance",
                    "prose": "Based on the outcome of the audit procedure, use `visudo -f <PATH TO FILE>` to edit the relevant sudoers file.\n\nRemove any line with occurrences of `NOPASSWD` tags in the file."
                  },
                  {
                    "name": "assessment-method",
                    "id": "cis-5.2.4_assessment-method",
                    "prose": "**Note:** If passwords are not being used for authentication, this is not applicable.\n\nVerify the operating system requires users to supply a password for privilege escalation.\n\nCheck the configuration of the `/etc/sudoers` and `/etc/sudoers.d/*` files with the following command:\n\n```\n# grep -r \"^[^#].*NOPASSWD\" /etc/sudoers*\n```\n\nIf any line is found refer to the remediation procedure below.",
                    "props": [
                      {
                        "name": "method",
                        "value": "TEST",
                        "ns": "http://csrc.nist.gov/ns/rmf"
                      }
                    ]
                  }
                ]
              }
            ],
            "groups": []
          },
          {
            "id": "section-5-3",
            "title": "Pluggable Authentication Modules",
            "props": [
              {
                "name": "label",
                "value": "5.3"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-5-3-1",
                "title": "Configure PAM software packages",
                "props": [
                  {
                    "name": "label",
                    "value": "5.3.1"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-5-3-2",
                "title": "Configure authselect",
                "props": [
                  {
                    "name": "label",
                    "value": "5.3.2"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-5-3-3",
                "title": "Configure PAM Arguments",
                "props": [
                  {
                    "name": "label",
                    "value": "5.3.3"
                  }
                ],
                "controls": [],
                "groups": [
                  {
                    "id": "section-5-3-3-1",
                    "title": "Configure pam_faillock module",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.3.3.1"
                      }
                    ],
                    "controls": [
                      {
                        "id": "cis-5.3.3.1.3",
                        "title": "Ensure password failed attempts lockout includes root account",
                        "props": [
                          {
                            "name": "label",
                            "value": "5.3.3.1.3"
                          }
                        ],
                        "parts": [
                          {
                            "name": "statement",
                            "id": "cis-5.3.3.1.3_statement",
                            "prose": "`even_deny_root` - Root account can become locked as well as regular accounts\n\n`root_unlock_time=n` - This option implies even_deny_root option. Allow access after n seconds to root account after the account is locked. In case the option is not specified the value is the same as of the unlock_time option."
                          },
                          {
                            "name": "assessment-objective",
                            "id": "cis-5.3.3.1.3_assessment-objective",
                            "prose": "Rationale: Locking out user IDs after n unsuccessful consecutive login attempts mitigates brute force password attacks against your systems.\nImpact: Use of `unlock_time=0` or `root_unlock_time=0` may allow an attacker to cause denial of service to legitimate users."
                          },
                          {
                            "name": "guidance",
                            "id": "cis-5.3.3.1.3_guidance",
                            "prose": "Edit `/etc/security/faillock.conf`:\n- Remove or update any line containing `root_unlock_time`, **- OR -** set it to a value of `60` or more\n- Update or add the following line:\n\n```\neven_deny_root\n```\n\nRun the following script to remove the `even_deny_root` and `root_unlock_time` arguments from the `pam_faillock.so` module in the PAM files:\n\n```\n#!/usr/bin/env bash\n{\n for l_pam_file in system-auth password-auth; do\n l_authselect_file=\"/etc/authselect/$(head -1 /etc/authselect/authselect.conf | grep 'custom/')/$l_pam_file\"\n sed -ri 's/(^\\s*auth\\s+(.*)\\s+pam_faillock\\.so.*)(\\s+even_deny_root)(.*$)/\\1\\4/' \"$l_authselect_file\"\n sed -ri 's/(^\\s*auth\\s+(.*)\\s+pam_faillock\\.so.*)(\\s+root_unlock_time\\s*=\\s*\\S+)(.*$)/\\1\\4/' \"$l_authselect_file\"\n done\n authselect apply-changes\n}\n``"
                          },
                          {
                            "name": "assessment-method",
                            "id": "cis-5.3.3.1.3_assessment-method",
                            "prose": "Run the following command to verify that `even_deny_root` and/or `root_unlock_time` is enabled:\n\n```\n# grep -Pi -- '^\\h*(even_deny_root|root_unlock_time\\h*=\\h*\\d+)\\b' /etc/security/faillock.conf\n```\n\n_Example output:_\n\n```\neven_deny_root\n\n--AND/OR--\n\nroot_unlock_time = 60\n```\n\nRun the following command to verify that **- IF -** `root_unlock_time` is set, it is set to `60` (One minute) or more:\n\n```\n# grep -Pi -- '^\\h*root_unlock_time\\h*=\\h*([1-9]|[1-5][0-9])\\b' /etc/security/faillock.conf\n\nNothing should be returned\n```\n\nRun the following command to check the `pam_faillock.so` module for the `root_unlock_time` argument. Verify **- IF -** `root_unlock_time` is set, it is set to `60` (One minute) or more:\n\n```\n# grep -Pi -- '^\\h*auth\\h+([^#\\n\\r]+\\h+)pam_faillock\\.so\\h+([^#\\n\\r]+\\h+)?root_unlock_time\\h*=\\h*([1-9]|[1-5][0-9])\\b' /etc/pam.d/system-auth /etc/pam.d/password-auth\n\nNothing should be returned\n```",
                            "props": [
                              {
                                "name": "method",
                                "value": "TEST",
                                "ns": "http://csrc.nist.gov/ns/rmf"
                              }
                            ]
                          }
                        ]
                      }
                    ],
                    "groups": []
                  },
                  {
                    "id": "section-5-3-3-2",
                    "title": "Configure pam_pwquality module",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.3.3.2"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  },
                  {
                    "id": "section-5-3-3-3",
                    "title": "Configure pam_pwhistory module",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.3.3.3"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  },
                  {
                    "id": "section-5-3-3-4",
                    "title": "Configure pam_unix module",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.3.3.4"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  }
                ]
              }
            ]
          },
          {
            "id": "section-5-4",
            "title": "User Accounts and Environment",
            "props": [
              {
                "name": "label",
                "value": "5.4"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-5-4-1",
                "title": "Configure shadow password suite parameters",
                "props": [
                  {
                    "name": "label",
                    "value": "5.4.1"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-5.4.1.2",
                    "title": "Ensure minimum password days is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.4.1.2"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-5.4.1.2_statement",
                        "prose": "`PASS_MIN_DAYS` <_N_> - The minimum number of days allowed between password changes. Any password changes attempted sooner than this will be rejected. If not specified, 0 will be assumed (which disables the restriction)."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-5.4.1.2_assessment-objective",
                        "prose": "Rationale: Users may have favorite passwords that they like to use because they are easy to remember and they believe that their password choice is secure from compromise. Unfortunately, passwords are compromised and if an attacker is targeting a specific individual user account, with foreknowledge of data about that user, reuse of old, potentially compromised passwords, may cause a security breach.\n\nBy restricting the frequency of password changes, an administrator can prevent users from repeatedly changing their password in an attempt to circumvent password reuse controls\nImpact: If a users password is set by other personnel as a procedure in dealing with a lost or expired password, the user should be forced to update this \"set\" password with their own password. e.g. force \"change at next logon\".\n\nIf it is not possible to have a user set their own password immediately, and this recommendation or local site procedure may cause a user to continue using a third party generated password, `PASS_MIN_DAYS` for the effected user should be temporally changed to `0`, to allow a user to change their password immediately.\n\nFor applications where the user is not using the password at console, the ability to \"change at next logon\" may be limited. This may cause a user to continue to use a password created by other personnel."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-5.4.1.2_guidance",
                        "prose": "Edit `/etc/login.defs` and set `PASS_MIN_DAYS` to a value greater than `0` that follows local site policy:\n\n_Example:_\n\n```\nPASS_MIN_DAYS 1\n```\n\nRun the following command to modify user parameters for all users with a password set to a minimum days greater than zero that follows local site policy:\n\n```\n# chage --mindays <N> <user>\n```\n\n_Example:_\n\n```\n# awk -F: '($2~/^\\$.+\\$/) {if($4 < 1)system (\"chage --mindays 1 \" $1)}' /etc/shadow\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-5.4.1.2_assessment-method",
                        "prose": "Run the following command to verify that `PASS_MIN_DAYS` is set to a value greater than `0`and follows local site policy:\n\n```\n# grep -Pi -- '^\\h*PASS_MIN_DAYS\\h+\\d+\\b' /etc/login.defs\n```\n\n_Example output:_\n\n```\nPASS_MIN_DAYS 1\n```\n\nRun the following command to verify all passwords have a `PASS_MIN_DAYS` greater than `0`:\n\n```\n# awk -F: '($2~/^\\$.+\\$/) {if($4 < 1)print \"User: \" $1 \" PASS_MIN_DAYS: \" $4}' /etc/shadow\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-5-4-2",
                "title": "Configure root and system accounts and environment",
                "props": [
                  {
                    "name": "label",
                    "value": "5.4.2"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-5-4-3",
                "title": "Configure user default environment",
                "props": [
                  {
                    "name": "label",
                    "value": "5.4.3"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-5.4.3.1",
                    "title": "Ensure nologin is not listed in /etc/shells",
                    "props": [
                      {
                        "name": "label",
                        "value": "5.4.3.1"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-5.4.3.1_statement",
                        "prose": "`/etc/shells` is a text file which contains the full pathnames of valid login shells. This file is consulted by `chsh` and available to be queried by other programs.\n\nBe aware that there are programs which consult this file to find out if a user is a normal user; for example, FTP daemons traditionally disallow access to users with shells not included in this file."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-5.4.3.1_assessment-objective",
                        "prose": "Rationale: A user can use `chsh` to change their configured shell.\n\nIf a user has a shell configured that isn't in in `/etc/shells`, then the system assumes that they're somehow restricted. In the case of `chsh` it means that the user cannot change that value.\n\nOther programs might query that list and apply similar restrictions.\n\nBy putting `nologin` in `/etc/shells`, any user that has `nologin` as its shell is considered a full, unrestricted user. This is not the expected behavior for `nologin`."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-5.4.3.1_guidance",
                        "prose": "Edit `/etc/shells` and remove any lines that include `nologin`"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-5.4.3.1_assessment-method",
                        "prose": "Run the following command to verify that `nologin` is not listed in the `/etc/shells` file:\n\n```\n# grep -Ps '^\\h*([^#\\n\\r]+)?\\/nologin\\b' /etc/shells\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              }
            ]
          }
        ]
      },
      {
        "id": "section-6",
        "title": "Logging and Auditing",
        "props": [
          {
            "name": "label",
            "value": "6"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-6-1",
            "title": "Configure Integrity Checking",
            "props": [
              {
                "name": "label",
                "value": "6.1"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-6-2",
            "title": "System Logging",
            "props": [
              {
                "name": "label",
                "value": "6.2"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-6-2-1",
                "title": "Configure systemd-journald service",
                "props": [
                  {
                    "name": "label",
                    "value": "6.2.1"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-6-2-2",
                "title": "Configure journald",
                "props": [
                  {
                    "name": "label",
                    "value": "6.2.2"
                  }
                ],
                "controls": [],
                "groups": [
                  {
                    "id": "section-6-2-2-1",
                    "title": "Configure systemd-journal-remote",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.2.2.1"
                      }
                    ],
                    "controls": [],
                    "groups": []
                  }
                ]
              },
              {
                "id": "section-6-2-3",
                "title": "Configure rsyslog",
                "props": [
                  {
                    "name": "label",
                    "value": "6.2.3"
                  }
                ],
                "controls": [],
                "groups": []
              },
              {
                "id": "section-6-2-4",
                "title": "Configure Logfiles",
                "props": [
                  {
                    "name": "label",
                    "value": "6.2.4"
                  }
                ],
                "controls": [],
                "groups": []
              }
            ]
          },
          {
            "id": "section-6-3",
            "title": "System Auditing",
            "props": [
              {
                "name": "label",
                "value": "6.3"
              }
            ],
            "controls": [],
            "groups": [
              {
                "id": "section-6-3-1",
                "title": "Configure auditd Service",
                "props": [
                  {
                    "name": "label",
                    "value": "6.3.1"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-6.3.1.1",
                    "title": "Ensure auditd packages are installed",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.1.1"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.1.1_statement",
                        "prose": "`auditd` is the userspace component to the Linux Auditing System. It's responsible for writing audit records to the disk."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.1.1_assessment-objective",
                        "prose": "Rationale: The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.1.1_guidance",
                        "prose": "Run the following command to install `audit` and `audit-libs`:\n\n```\n# dnf install audit audit-libs\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.1.1_assessment-method",
                        "prose": "Run the following command and verify `audit` and `audit-libs` packages are installed:\n\n``` \n# rpm -q audit audit-libs\n\naudit-<version>\naudit-libs-<version>\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.1.2",
                    "title": "Ensure auditing for processes that start prior to auditd is enabled",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.1.2"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.1.2_statement",
                        "prose": "Configure `grub2` so that processes that are capable of being audited can be audited even if they start up prior to `auditd` startup."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.1.2_assessment-objective",
                        "prose": "Rationale: Audit events need to be captured on processes that start up prior to `auditd` , so that potential malicious activity cannot go undetected."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.1.2_guidance",
                        "prose": "Run the following command to update the `grub2` configuration with `audit=1`:\n\n```\n# grubby --update-kernel ALL --args 'audit=1'\n```\n\nEdit `/etc/default/grub` and add `audit=1` to the `GRUB_CMDLINE_LINUX=` line between the opening and closing double quotes:\n\n_Example:_\n\n```\nGRUB_CMDLINE_LINUX=\"quiet audit=1\"\n```\n\n**Note:** Other parameters may also be listed"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.1.2_assessment-method",
                        "prose": "**Note:** `/etc/default/grub` should be checked because the `grub2-mkconfig -o` command will overwrite `grub.cfg` with parameters listed in `/etc/default/grub`.\n\nRun the following command to verify that the `audit=1` parameter has been set:\n\n```\n# grubby --info=ALL | grep -Po '\\baudit=1\\b'\n\naudit=1\n```\n\n**Note:** `audit=1` may be returned multiple times\n\nRun the following command to verify that the `audit=1` parameter has been set in `/etc/default/grub`:\n\n```\n# grep -Psoi -- '^\\h*GRUB_CMDLINE_LINUX=\\\"([^#\\n\\r]+\\h+)?audit=1\\b' /etc/default/grub\n```\n\n_Example output:_\n\n```\nGRUB_CMDLINE_LINUX=\"quiet audit=1\"\n```\n\n**Note:** Other parameters may also be listed",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.1.3",
                    "title": "Ensure audit_backlog_limit is sufficient",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.1.3"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.1.3_statement",
                        "prose": "The `audit_backlog_limit` parameter determines how auditd records can be held in the auditd backlog. The default setting of 64 may be insufficient to store all audit events during boot."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.1.3_assessment-objective",
                        "prose": "Rationale: During boot if `audit=1`, then the backlog will hold 64 records. If more than 64 records are created during boot, auditd records will be lost and potential malicious activity could go undetected."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.1.3_guidance",
                        "prose": "Run the following command to add `audit_backlog_limit=<BACKLOG SIZE>` to GRUB_CMDLINE_LINUX:\n\n```\n# grubby --update-kernel ALL --args 'audit_backlog_limit=<BACKLOG SIZE>'\n```\n\n_Example:_\n```\n# grubby --update-kernel ALL --args 'audit_backlog_limit=8192'\n```\n\nEdit `/etc/default/grub` and add `audit_backlog_limit=<BACKLOG SIZE>` to the `GRUB_CMDLINE_LINUX=` line between the opening and closing double quotes:\n\n_Example:_\n\n```\nGRUB_CMDLINE_LINUX=\"quiet audit_backlog_limit=8192\"\n```\n\n**Note:** Other parameters may also be listed"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.1.3_assessment-method",
                        "prose": "**Note:** `/etc/default/grub` should be checked because the `grub2-mkconfig -o` command will overwrite `grub.cfg` with parameters listed in `/etc/default/grub`.\n\nRun the following command and verify the `audit_backlog_limit=` parameter is set to an appropriate size for your organization\n\n```\n# grubby --info=ALL | grep -Po \"\\baudit_backlog_limit=\\d+\\b\"\n\naudit_backlog_limit=<BACKLOG SIZE>\n```\n\nValidate that the line(s) returned contain a value for `audit_backlog_limit=` that is sufficient for your organization. \n\n**Recommended that this value be `8192` or larger.**\n\nRun the following command to verify that the `audit_backlog_limit=<BACKLOG SIZE>` parameter has been set in `/etc/default/grub`:\n\n```\n# grep -Psoi -- '^\\h*GRUB_CMDLINE_LINUX=\\\"([^#\\n\\r]+\\h+)?\\baudit_backlog_limit=\\d+\\b' /etc/default/grub\n```\n\n_Example output:_\n\n```\nGRUB_CMDLINE_LINUX=\"quiet audit_backlog_limit=8192\"\n```\n\n**Note:** Other parameters may also be listed",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.1.4",
                    "title": "Ensure auditd service is enabled and active",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.1.4"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.1.4_statement",
                        "prose": "Turn on the `auditd` daemon to record system events."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.1.4_assessment-objective",
                        "prose": "Rationale: The capturing of system events provides system administrators with information to allow them to determine if unauthorized access to their system is occurring."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.1.4_guidance",
                        "prose": "Run the following commands to unmask, enable and start `auditd`:\n\n```\n# systemctl unmask auditd\n# systemctl enable auditd\n# systemctl start auditd\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.1.4_assessment-method",
                        "prose": "Run the following command to verify `auditd` is enabled:\n\n```\n# systemctl is-enabled auditd | grep '^enabled'\n\nenabled\n```\n\nVerify result is \"enabled\".\n\nRun the following command to verify `auditd` is active:\n\n```\n# systemctl is-active auditd | grep '^active'\n\nactive\n```\n\nVerify result is active",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-6-3-2",
                "title": "Configure Data Retention",
                "props": [
                  {
                    "name": "label",
                    "value": "6.3.2"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-6.3.2.1",
                    "title": "Ensure audit log storage size is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.2.1"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.2.1_statement",
                        "prose": "Configure the maximum size of the audit log file. Once the log reaches the maximum size, it will be rotated and a new log file will be started."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.2.1_assessment-objective",
                        "prose": "Rationale: It is important that an appropriate size is determined for log files so that they do not impact the system and audit data is not lost."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.2.1_guidance",
                        "prose": "Set the following parameter in `/etc/audit/auditd.conf` in accordance with site policy:\n\n```\nmax_log_file = <MB>\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.2.1_assessment-method",
                        "prose": "Run the following command and ensure output is in compliance with site policy:\n\n```\n# grep -Po -- '^\\h*max_log_file\\h*=\\h*\\d+\\b' /etc/audit/auditd.conf\n\nmax_log_file = <MB>\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.2.2",
                    "title": "Ensure audit logs are not automatically deleted",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.2.2"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.2.2_statement",
                        "prose": "The `max_log_file_action` setting determines how to handle the audit log file reaching the max file size. A value of `keep_logs` will rotate the logs but never delete old logs."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.2.2_assessment-objective",
                        "prose": "Rationale: In high security contexts, the benefits of maintaining a long audit history exceed the cost of storing the audit history."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.2.2_guidance",
                        "prose": "Set the following parameter in `/etc/audit/auditd.conf:` \n\n```\nmax_log_file_action = keep_logs\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.2.2_assessment-method",
                        "prose": "Run the following command and verify output matches:\n\n```\n# grep max_log_file_action /etc/audit/auditd.conf\n\nmax_log_file_action = keep_logs\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.2.3",
                    "title": "Ensure system is disabled when audit logs are full",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.2.3"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.2.3_statement",
                        "prose": "The `auditd` daemon can be configured to halt the system or put the system in single user mode, if no free space is available or an error is detected on the partition that holds the audit log files.\n\nThe `disk_full_action` parameter tells the system what action to take when no free space is available on the partition that holds the audit log files. Valid values are `ignore`, `syslog`, `rotate`, `exec`, `suspend`, `single`, and `halt`.\n- `ignore`, the audit daemon will issue a syslog message but no other action is taken\n- `syslog`, the audit daemon will issue a warning to syslog\n- `rotate`, the audit daemon will rotate logs, losing the oldest to free up space\n- `exec`, /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action\n- `suspend`, the audit daemon will stop writing records to the disk\n- `single`, the audit daemon will put the computer system in single user mode\n- `halt`, the audit daemon will shut down the system\n\nThe `disk_error_action` parameter tells the system what action to take when an error is detected on the partition that holds the audit log files. Valid values are `ignore`, `syslog`, `exec`, `suspend`, `single`, and `halt`.\n- `ignore`, the audit daemon will not take any action\n- `syslog`, the audit daemon will issue no more than 5 consecutive warnings to syslog\n- `exec`, /path-to-script will execute the script. You cannot pass parameters to the script\n- `suspend`, the audit daemon will stop writing records to the disk\n- `single`, the audit daemon will put the computer system in single user mode\n- `halt`, the audit daemon will shut down the system"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.2.3_assessment-objective",
                        "prose": "Rationale: In high security contexts, the risk of detecting unauthorized access or nonrepudiation exceeds the benefit of the system's availability.\nImpact: `disk_full_action` parameter:\n- Set to `halt` - the `auditd` daemon will shutdown the system when the disk partition containing the audit logs becomes full.\n- Set to `single` - the `auditd` daemon will put the computer system in single user mode when the disk partition containing the audit logs becomes full.\n\n`disk_error_action` parameter:\n- Set to `halt` - the `auditd` daemon will shutdown the system when an error is detected on the partition that holds the audit log files.\n- Set to `single` - the `auditd` daemon will put the computer system in single user mode when an error is detected on the partition that holds the audit log files.\n- Set to `syslog` - the `auditd` daemon will issue no more than 5 consecutive warnings to syslog when an error is detected on the partition that holds the audit log files."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.2.3_guidance",
                        "prose": "Set one of the following parameters in `/etc/audit/auditd.conf` depending on your local security policies. \n\n```\ndisk_full_action = <halt|single>\ndisk_error_action = <syslog|single|halt>\n```\n\n_Example:_\n\n```\ndisk_full_action = halt\ndisk_error_action = halt\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.2.3_assessment-method",
                        "prose": "Run the following command and verify the `disk_full_action` is set to either `halt` or `single`:\n\n```\n# grep -P -- '^\\h*disk_full_action\\h*=\\h*(halt|single)\\b' /etc/audit/auditd.conf\n\ndisk_full_action = <halt|single>\n```\n\nRun the following command and verify the `disk_error_action` is set to `syslog`, `single`, or `halt`:\n\n```\n# grep -P -- '^\\h*disk_error_action\\h*=\\h*(syslog|single|halt)\\b' /etc/audit/auditd.conf\n\ndisk_error_action = <syslog|single|halt>\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.2.4",
                    "title": "Ensure system warns when audit logs are low on space",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.2.4"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.2.4_statement",
                        "prose": "The `auditd` daemon can be configured to halt the system, put the system in single user mode or send a warning message, if the partition that holds the audit log files is low on space.\n\nThe `space_left_action` parameter tells the system what action to take when the system has detected that it is starting to get low on disk space. Valid values are `ignore`, `syslog`, `rotate`, `email`, `exec`, `suspend`, `single`, and `halt`.\n- `ignore`, the audit daemon does nothing\n- `syslog`, the audit daemon will issue a warning to syslog\n- `rotate`, the audit daemon will rotate logs, losing the oldest to free up space\n- `email`, the audit daemon will send a warning to the email account specified in `action_mail_acct` as well as sending the message to syslog\n- `exec`, /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action\n- `suspend`, the audit daemon will stop writing records to the disk\n- `single`, the audit daemon will put the computer system in single user mode\n- `halt`, the audit daemon will shut down the system\n\nThe `admin_space_left_action` parameter tells the system what action to take when the system has detected that it is low on disk space. Valid values are `ignore`, `syslog`, `rotate`, `email`, `exec`, `suspend`, `single`, and `halt`.\n- `ignore`, the audit daemon does nothing\n- `syslog`, the audit daemon will issue a warning to syslog\n- `rotate`, the audit daemon will rotate logs, losing the oldest to free up space\n- `email`, the audit daemon will send a warning to the email account specified in `action_mail_acct` as well as sending the message to syslog\n- `exec`, /path-to-script will execute the script. You cannot pass parameters to the script. The script is also responsible for telling the auditd daemon to resume logging once its completed its action\n- `suspend`, the audit daemon will stop writing records to the disk\n- `single`, the audit daemon will put the computer system in single user mode\n- `halt`, the audit daemon will shut down the system"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.2.4_assessment-objective",
                        "prose": "Rationale: In high security contexts, the risk of detecting unauthorized access or nonrepudiation exceeds the benefit of the system's availability.\nImpact: If the `admin_space_left_action` is set to `single` the audit daemon will put the computer system in single user mode."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.2.4_guidance",
                        "prose": "Set the `space_left_action` parameter in `/etc/audit/auditd.conf` to `email`, `exec`, `single`, or `halt`:\n\n_Example:_\n\n```\nspace_left_action = email\n```\n\nSet the `admin_space_left_action` parameter in `/etc/audit/auditd.conf` to `single` or `halt`:\n\n_Example:_\n\n```\nadmin_space_left_action = single\n```\n\n**Note:** A Mail Transfer Agent (MTA) must be installed and configured properly to set `space_left_action = email`"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.2.4_assessment-method",
                        "prose": "Run the following command and verify the `space_left_action` is set to `email`, `exec`, `single`, or `halt`:\n\n```\ngrep -P -- '^\\h*space_left_action\\h*=\\h*(email|exec|single|halt)\\b' /etc/audit/auditd.conf\n```\n\nVerify the output is `email`, `exec`, `single`, or `halt`\n\n_Example output_\n\n```\nspace_left_action = email\n```\n\nRun the following command and verify the `admin_space_left_action` is set to `single` **- OR -** `halt`:\n\n```\ngrep -P -- '^\\h*admin_space_left_action\\h*=\\h*(single|halt)\\b' /etc/audit/auditd.conf\n```\n\nVerify the output is `single` or `halt`\n\n_Example output:_\n\n```\nadmin_space_left_action = single\n```\n\n**Note:** A Mail Transfer Agent (MTA) must be installed and configured properly to set `space_left_action = email`",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-6-3-3",
                "title": "Configure auditd Rules",
                "props": [
                  {
                    "name": "label",
                    "value": "6.3.3"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-6.3.3.1",
                    "title": "Ensure changes to system administration scope (sudoers) is collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.1"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.1_statement",
                        "prose": "Monitor scope changes for system administrators. If the system has been properly configured to force system administrators to log in as themselves first and then use the `sudo` command to execute privileged commands, it is possible to monitor changes in scope. The file `/etc/sudoers`, or files in `/etc/sudoers.d`, will be written to when the file(s) or related attributes have changed. The audit records will be tagged with the identifier \"scope\"."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.1_assessment-objective",
                        "prose": "Rationale: Changes in the `/etc/sudoers` and `/etc/sudoers.d` files can indicate that an unauthorized change has been made to the scope of system administrator activity."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.1_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor scope changes for system administrators.\n\n_Example:_\n\n```\n# printf '%s\\n' \"-w /etc/sudoers -p wa -k scope\" \"-w /etc/sudoers.d -p wa -k scope\" >> /etc/audit/rules.d/50-scope.rules\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.1_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-w/ \\\n&&/\\/etc\\/sudoers/ \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-w /etc/sudoers -p wa -k scope\n-w /etc/sudoers.d -p wa -k scope\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-w/ \\\n&&/\\/etc\\/sudoers/ \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-w /etc/sudoers -p wa -k scope\n-w /etc/sudoers.d -p wa -k scope\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.2",
                    "title": "Ensure actions as another user are always logged",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.2"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.2_statement",
                        "prose": "`sudo` provides users with temporary elevated privileges to perform operations, either as the superuser or another user."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.2_assessment-objective",
                        "prose": "Rationale: Creating an audit log of users with temporary elevated privileges and the operation(s) they performed is essential to reporting. Administrators will want to correlate the events written to the audit trail with the records written to `sudo`'s logfile to verify if unauthorized commands have been executed."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.2_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor elevated privileges.\n\n_Example:_\n\n```\n# printf \"\n-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation \n-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation\n\" >> /etc/audit/rules.d/50-user_emulation.rules\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.2_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-a *always,exit/ \\\n&&/ -F *arch=b(32|64)/ \\\n&&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n&&(/ -C *euid!=uid/||/ -C *uid!=euid/) \\\n&&/ -S *execve/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation \n-a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-a *always,exit/ \\\n&&/ -F *arch=b(32|64)/ \\\n&&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n&&(/ -C *euid!=uid/||/ -C *uid!=euid/) \\\n&&/ -S *execve/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S execve -C uid!=euid -F auid!=-1 -F key=user_emulation\n-a always,exit -F arch=b32 -S execve -C uid!=euid -F auid!=-1 -F key=user_emulation\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.3",
                    "title": "Ensure events that modify the sudo log file are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.3"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.3_statement",
                        "prose": "Monitor the `sudo` log file. If the system has been properly configured to disable the use of the `su` command and force all administrators to have to log in first and then use `sudo` to execute privileged commands, then all administrator commands will be logged to `/var/log/sudo.log` . Any time a command is executed, an audit event will be triggered as the `/var/log/sudo.log` file will be opened for write and the executed administration command will be written to the log."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.3_assessment-objective",
                        "prose": "Rationale: Changes in `/var/log/sudo.log` indicate that an administrator has executed a command or the log file itself has been tampered with. Administrators will want to correlate the events written to the audit trail with the records written to `/var/log/sudo.log` to verify if unauthorized commands have been executed."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.3_guidance",
                        "prose": "**Note:** This recommendation requires that the sudo logfile is configured. See guidance provided in the recommendation \"Ensure sudo log file exists\"\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor events that modify the sudo log file.\n\n_Example:_\n\n```\n# {\nSUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g')\n[ -n \"${SUDO_LOG_FILE}\" ] && printf \"\n-w ${SUDO_LOG_FILE} -p wa -k sudo_log_file\n\" >> /etc/audit/rules.d/50-sudo.rules || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\\n\"\n}\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.3_assessment-method",
                        "prose": "**Note:** This recommendation requires that the sudo logfile is configured. See guidance provided in the recommendation \"Ensure sudo log file exists\"\n\n**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g')\n [ -n \"${SUDO_LOG_FILE}\" ] && awk \"/^ *-w/ \\\n &&/\"${SUDO_LOG_FILE}\"/ \\\n &&/ +-p *wa/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\\n\"\n}\n```\n\nVerify output of matches:\n\n```\n-w /var/log/sudo.log -p wa -k sudo_log_file\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n SUDO_LOG_FILE=$(grep -r logfile /etc/sudoers* | sed -e 's/.*logfile=//;s/,? .*//' -e 's/\"//g' -e 's|/|\\\\/|g')\n [ -n \"${SUDO_LOG_FILE}\" ] && auditctl -l | awk \"/^ *-w/ \\\n &&/\"${SUDO_LOG_FILE}\"/ \\\n &&/ +-p *wa/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'SUDO_LOG_FILE' is unset.\\n\"\n}\n```\n\nVerify output matches:\n\n```\n-w /var/log/sudo.log -p wa -k sudo_log_file\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.4",
                    "title": "Ensure events that modify date and time information are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.4"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.4_statement",
                        "prose": "Capture events where the system date and/or time has been modified. The parameters in this section are set to determine if the;\n- `adjtimex` - tune kernel clock\n- `settimeofday` - set time using `timeval` and `timezone` structures\n- `stime` - using seconds since 1/1/1970\n- `clock_settime` - allows for the setting of several internal clocks and timers\n\nsystem calls have been executed. Further, ensure to write an audit record to the configured audit log file upon exit, tagging the records with a unique identifier such as \"time-change\"."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.4_assessment-objective",
                        "prose": "Rationale: Unexpected changes in system date and/or time could be a sign of malicious activity on the system."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.4_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor events that modify date and time information.\n\nExample:\n\n```\n# printf \"\n-a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change\n-a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change\n-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change\n-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change\n-w /etc/localtime -p wa -k time-change\n\" >> /etc/audit/rules.d/50-time-change.rules\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.4_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n awk '/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&/ -S/ \\\n &&(/adjtimex/ \\\n ||/settimeofday/ \\\n ||/clock_settime/ ) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n\n awk '/^ *-w/ \\\n &&/\\/etc\\/localtime/ \\\n &&/ +-p *wa/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n}\n```\n\nVerify output of matches:\n\n```\n-a always,exit -F arch=b64 -S adjtimex,settimeofday -k time-change\n-a always,exit -F arch=b32 -S adjtimex,settimeofday -k time-change\n-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -k time-change\n-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -k time-change\n-w /etc/localtime -p wa -k time-change\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n auditctl -l | awk '/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&/ -S/ \\\n &&(/adjtimex/ \\\n ||/settimeofday/ \\\n ||/clock_settime/ ) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n\n auditctl -l | awk '/^ *-w/ \\\n &&/\\/etc\\/localtime/ \\\n &&/ +-p *wa/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n}\n```\n\nVerify the output includes:\n\n```\n-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=time-change\n-a always,exit -F arch=b32 -S settimeofday,adjtimex -F key=time-change\n-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change\n-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change\n-w /etc/localtime -p wa -k time-change\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.5",
                    "title": "Ensure events that modify the system's network environment are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.5"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.5_statement",
                        "prose": "Record changes to network environment files or system calls. The below parameters monitors the following system calls, and write an audit event on system call exit:\n- `sethostname` - set the systems host name\n- `setdomainname` - set the systems domain name\n\nThe files being monitored are:\n- `/etc/issue` and `/etc/issue.net` - messages displayed pre-login\n- `/etc/hosts` - file containing host names and associated IP addresses\n- `/etc/hostname` - file contains the system's host name\n- `/etc/sysconfig/network` - additional information that is valid to all network interfaces\n- `/etc/sysconfig/network-scripts/` - directory containing network interface scripts and configurations files\n- `/etc/NetworkManager/` - directory contains configuration files and settings used by the `NetworkManager`"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.5_assessment-objective",
                        "prose": "Rationale: Monitoring `sethostname` and `setdomainname` will identify potential unauthorized changes to host and domain name of a system. The changing of these names could potentially break security parameters that are set based on those names. The `/etc/hosts` file is monitored for changes that can indicate an unauthorized intruder is trying to change machine associations with IP addresses and trick users and processes into connecting to unintended machines. Monitoring `/etc/issue` and `/etc/issue.net` is important, as intruders could put disinformation into those files and trick users into providing information to the intruder. Monitoring `/etc/sysconfig/network` is important as it can show if network interfaces or scripts are being modified in a way that can lead to the machine becoming unavailable or compromised. All audit records should have a relevant tag associated with them."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.5_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor events that modify the system's network environment.\n\nExample:\n\n```\n# printf \"\n-a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale\n-a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale\n-w /etc/issue -p wa -k system-locale\n-w /etc/issue.net -p wa -k system-locale\n-w /etc/hosts -p wa -k system-locale\n-w /etc/hostname -p wa -k system-locale\n-w /etc/sysconfig/network -p wa -k system-locale\n-w /etc/sysconfig/network-scripts/ -p wa -k system-locale\n-w /etc/NetworkManager -p wa -k system-locale\n\" >> /etc/audit/rules.d/50-system_locale.rules\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.5_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following commands to check the on disk rules:\n\n```\n# {\n# Check for syscalls related to hostname and domainname change\nawk '/^*-a *always, exit/ \\\n&& /-F *arch=b(32|64)/ \\\n&& /-S/ && (/sethostname/ \\\n|| /setdomainname/) \\\n&& (/skey= *[!-~]* *$/ || /-k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n\n# Check for file watches on network-related files\nawk '/^ *-w/ \\\n&& (/etc\\/issue/ \\\n|| /etc\\/issue.net/ \\\n|| /etc\\/hosts/ \\\n|| /etc\\/sysconfig\\/network/ \\\n|| /etc\\/hostname/ \\\n|| /etc\\/NetworkManager/) \\\n&& / +-p *wa/ \\\n&& (/ key= *[!-~]* *$/ || /-k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale\n-a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale\n-w /etc/issue -p wa -k system-locale\n-w /etc/issue.net -p wa -k system-locale\n-w /etc/hosts -p wa -k system-locale\n-w /etc/hostname -p wa -k system-locale\n-w /etc/sysconfig/network -p wa -k system-locale\n-w /etc/sysconfig/network-scripts/ -p wa -k system-locale\n-w /etc/NetworkManager -p wa -k system-locale\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n auditctl -l | awk '/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&/ -S/ \\\n &&(/sethostname/ \\\n ||/setdomainname/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n\n auditctl -l | awk '/^ *-w/ \\\n &&(/etc\\/issue/ \\\n || /etc\\/issue.net/ \\\n || /etc\\/hosts/ \\\n || /etc\\/sysconfig\\/network/ \\\n || /etc\\/hostname/ \\\n || /etc\\/NetworkManager/) \\\n &&/ +-p *wa/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n}\n```\n\nVerify the output includes:\n\n```\n-a always,exit -F arch=b64 -S sethostname,setdomainname -F key=system-locale\n-a always,exit -F arch=b32 -S sethostname,setdomainname -F key=system-locale\n-w /etc/issue -p wa -k system-locale\n-w /etc/issue.net -p wa -k system-locale\n-w /etc/hosts -p wa -k system-locale\n-w /etc/hostname -p wa -k system-locale\n-w /etc/sysconfig/network -p wa -k system-locale\n-w /etc/sysconfig/network-scripts -p wa -k system-locale\n-w /etc/NetworkManager -p wa -k system-locale\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.6",
                    "title": "Ensure use of privileged commands are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.6"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.6_statement",
                        "prose": "Monitor privileged programs, those that have the `setuid` and/or `setgid` bit set on execution, to determine if unprivileged users are running these commands."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.6_assessment-objective",
                        "prose": "Rationale: Execution of privileged commands by non-privileged users could be an indication of someone trying to gain unauthorized access to the system.\nImpact: Both the audit and remediation section of this recommendation will traverse all mounted file systems that is not mounted with either `noexec` or `nosuid` mount options. If there are large file systems without these mount options, **such traversal will be significantly detrimental to the performance of the system.**\n\nBefore running either the audit or remediation section, inspect the output of the following command to determine exactly which file systems will be traversed:\n\n```\n# findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\"\n```\n\nTo exclude a particular file system due to adverse performance impacts, update the audit and remediation sections by adding a sufficiently unique string to the `grep` statement. The above command can be used to test the modified exclusions."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.6_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor the use of privileged commands.\n\n_Example script:_\n\n```\n#!/usr/bin/env bash\n\n{\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n AUDIT_RULE_FILE=\"/etc/audit/rules.d/50-privileged.rules\"\n NEW_DATA=()\n for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\" | awk '{print $1}'); do\n readarray -t DATA < <(find \"${PARTITION}\" -xdev -perm /6000 -type f | awk -v UID_MIN=${UID_MIN} '{print \"-a always,exit -F path=\" $1 \" -F perm=x -F auid>=\"UID_MIN\" -F auid!=unset -k privileged\" }')\n for ENTRY in \"${DATA[@]}\"; do\n NEW_DATA+=(\"${ENTRY}\")\n done\n done\n readarray &> /dev/null -t OLD_DATA < \"${AUDIT_RULE_FILE}\"\n COMBINED_DATA=( \"${OLD_DATA[@]}\" \"${NEW_DATA[@]}\" )\n printf '%s\\n' \"${COMBINED_DATA[@]}\" | sort -u > \"${AUDIT_RULE_FILE}\"\n}\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```\n\n**Special mount points**\n\nIf there are any special mount points that are not visible by default from just scanning `/`, change the `PARTITION` variable to the appropriate partition and re-run the remediation."
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.6_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following script to check on disk rules:\n\n```\n#!/usr/bin/env bash\n\n{\n for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\" | awk '{print $1}'); do\n for PRIVILEGED in $(find \"${PARTITION}\" -xdev -perm /6000 -type f); do\n grep -qr \"${PRIVILEGED}\" /etc/audit/rules.d && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in on disk configuration.\\n\"\n done\n done\n}\n```\n\nVerify that all output is `OK`.\n\n**Running configuration**\n\nRun the following script to check loaded rules:\n\n```\n#!/usr/bin/env bash\n\n{\n RUNNING=$(auditctl -l)\n [ -n \"${RUNNING}\" ] && for PARTITION in $(findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv \"noexec|nosuid\" | awk '{print $1}'); do\n for PRIVILEGED in $(find \"${PARTITION}\" -xdev -perm /6000 -type f); do\n printf -- \"${RUNNING}\" | grep -q \"${PRIVILEGED}\" && printf \"OK: '${PRIVILEGED}' found in auditing rules.\\n\" || printf \"Warning: '${PRIVILEGED}' not found in running configuration.\\n\"\n done\n done \\\n || printf \"ERROR: Variable 'RUNNING' is unset.\\n\"\n}\n```\n\nVerify that all output is `OK`.\n\n**Special mount points**\n\nIf there are any special mount points that are not visible by default from `findmnt` as per the above audit, said file systems would have to be manually audited.",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.7",
                    "title": "Ensure unsuccessful file access attempts are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.7"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.7_statement",
                        "prose": "Monitor for unsuccessful attempts to access files. The following parameters are associated with system calls that control files:\n- creation - `creat`\n- opening - `open` , `openat`\n- truncation - `truncate` , `ftruncate`\n\nAn audit log record will only be written if all of the following criteria is met for the user when trying to access a file:\n- a non-privileged user (auid>=UID_MIN)\n- is not a Daemon event (auid=4294967295/unset/-1)\n- if the system call returned EACCES (permission denied) or EPERM (some other permanent error associated with the specific system call)"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.7_assessment-objective",
                        "prose": "Rationale: Failed attempts to open, create or truncate files could be an indication that an individual or process is trying to gain unauthorized access to the system."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.7_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor unsuccessful file access attempts.\n\n_Example:_\n\n```\n# {\nUID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n[ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access\n-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access\n-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=${UID_MIN} -F auid!=unset -k access\n-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=${UID_MIN} -F auid!=unset -k access\n\" >> /etc/audit/rules.d/50-access.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.7_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&(/ -F *exit=-EACCES/||/ -F *exit=-EPERM/) \\\n &&/ -S/ \\\n &&/creat/ \\\n &&/open/ \\\n &&/truncate/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output includes:\n\n```\n-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access\n-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -k access\n-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -k access\n-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -k access\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&(/ -F *exit=-EACCES/||/ -F *exit=-EPERM/) \\\n &&/ -S/ \\\n &&/creat/ \\\n &&/open/ \\\n &&/truncate/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output includes:\n\n```\n-a always,exit -F arch=b64 -S open,truncate,ftruncate,creat,openat -F exit=-EACCES -F auid>=1000 -F auid!=-1 -F key=access\n-a always,exit -F arch=b64 -S open,truncate,ftruncate,creat,openat -F exit=-EPERM -F auid>=1000 -F auid!=-1 -F key=access\n-a always,exit -F arch=b32 -S open,truncate,ftruncate,creat,openat -F exit=-EACCES -F auid>=1000 -F auid!=-1 -F key=access\n-a always,exit -F arch=b32 -S open,truncate,ftruncate,creat,openat -F exit=-EPERM -F auid>=1000 -F auid!=-1 -F key=access\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.8",
                    "title": "Ensure events that modify user/group information are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.8"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.8_statement",
                        "prose": "Record events affecting the modification of user or group information, including that of passwords and old passwords if in use.\n- `/etc/group` - system groups\n- `/etc/passwd` - system users\n- `/etc/gshadow` - encrypted password for each group\n- `/etc/shadow` - system user passwords\n- `/etc/security/opasswd` - storage of old passwords if the relevant PAM module is in use\n- `/etc/nsswitch.conf` - file configures how the system uses various databases and name resolution mechanisms\n- `/etc/pam.conf` - file determines the authentication services to be used, and the order in which the services are used.\n- `/etc/pam.d` - directory contains the PAM configuration files for each PAM-aware application.\n\nThe parameters in this section will watch the files to see if they have been opened for write or have had attribute changes (e.g. permissions) and tag them with the identifier \"identity\" in the audit log file."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.8_assessment-objective",
                        "prose": "Rationale: Unexpected changes to these files could be an indication that the system has been compromised and that an unauthorized user is attempting to hide their activities or compromise additional accounts."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.8_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor events that modify user/group information.\n\n_Example:_\n\n```\n# printf \"\n-w /etc/group -p wa -k identity\n-w /etc/passwd -p wa -k identity\n-w /etc/gshadow -p wa -k identity\n-w /etc/shadow -p wa -k identity\n-w /etc/security/opasswd -p wa -k identity\n-w /etc/nsswitch.conf -p wa -k identity\n-w /etc/pam.conf -p wa -k identity\n-w /etc/pam.d -p wa -k identity\n\" >> /etc/audit/rules.d/50-identity.rules\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.8_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-w/ \\\n&&(/\\/etc\\/group/ \\\n ||/\\/etc\\/passwd/ \\\n ||/\\/etc\\/gshadow/ \\\n ||/\\/etc\\/shadow/ \\\n ||/\\/etc\\/security\\/opasswd/ \\\n ||/\\/etc\\/nsswitch.conf/ \\\n ||/\\/etc\\/pam.conf/ \\\n ||/\\/etc\\/pam.d/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-w /etc/group -p wa -k identity\n-w /etc/passwd -p wa -k identity\n-w /etc/gshadow -p wa -k identity\n-w /etc/shadow -p wa -k identity\n-w /etc/security/opasswd -p wa -k identity\n-w /etc/nsswitch.conf -p wa -k identity\n-w /etc/pam.conf -p wa -k identity\n-w /etc/pam.d -p wa -k identity\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-w/ \\\n&&(/\\/etc\\/group/ \\\n ||/\\/etc\\/passwd/ \\\n ||/\\/etc\\/gshadow/ \\\n ||/\\/etc\\/shadow/ \\\n ||/\\/etc\\/security\\/opasswd/ \\\n ||/\\/etc\\/nsswitch.conf/ \\\n ||/\\/etc\\/pam.conf/ \\\n ||/\\/etc\\/pam.d/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-w /etc/group -p wa -k identity\n-w /etc/passwd -p wa -k identity\n-w /etc/gshadow -p wa -k identity\n-w /etc/shadow -p wa -k identity\n-w /etc/security/opasswd -p wa -k identity\n-w /etc/nsswitch.conf -p wa -k identity\n-w /etc/pam.conf -p wa -k identity\n-w /etc/pam.d -p wa -k identity\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.9",
                    "title": "Ensure discretionary access control permission modification events are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.9"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.9_statement",
                        "prose": "Monitor changes to file permissions, attributes, ownership and group. The parameters in this section track changes for system calls that affect file permissions and attributes. The following commands and system calls effect the permissions, ownership and various attributes of files.\n- `chmod`\n- `fchmod`\n- `fchmodat`\n- `chown`\n- `fchown`\n- `fchownat`\n- `lchown`\n- `setxattr`\n- `lsetxattr`\n- `fsetxattr`\n- `removexattr`\n- `lremovexattr`\n- `fremovexattr`\n\nIn all cases, an audit record will only be written for non-system user ids and will ignore Daemon events. All audit records will be tagged with the identifier \"perm_mod.\""
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.9_assessment-objective",
                        "prose": "Rationale: Monitoring for changes in file attributes could alert a system administrator to activity that could indicate intruder activity or policy violation."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.9_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor discretionary access control permission modification events.\n\n_Example:_\n\n```\n# {\nUID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n[ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=${UID_MIN} -F auid!=unset -F key=perm_mod\n\" >> /etc/audit/rules.d/50-perm_mod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.9_assessment-method",
                        "prose": "**Note:** Output showing all audited syscalls, e.g. (-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod) is also acceptable. These have been separated by function on the displayed output for clarity.\n\n**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -S/ \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&(/chmod/||/fchmod/||/fchmodat/ \\\n ||/chown/||/fchown/||/fchownat/||/lchown/ \\\n ||/setxattr/||/lsetxattr/||/fsetxattr/ \\\n ||/removexattr/||/lremovexattr/||/fremovexattr/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n```\n-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod\n-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -S/ \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&(/chmod/||/fchmod/||/fchmodat/ \\\n ||/chown/||/fchown/||/fchownat/||/lchown/ \\\n ||/setxattr/||/lsetxattr/||/fsetxattr/ \\\n ||/removexattr/||/lremovexattr/||/fremovexattr/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=-1 -F key=perm_mod\n-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=1000 -F auid!=-1 -F key=perm_mod\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.10",
                    "title": "Ensure successful file system mounts are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.10"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.10_statement",
                        "prose": "Monitor the use of the `mount` system call. The `mount` (and `umount` ) system call controls the mounting and unmounting of file systems. The parameters below configure the system to create an audit record when the mount system call is used by a non-privileged user"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.10_assessment-objective",
                        "prose": "Rationale: It is highly unusual for a non privileged user to `mount` file systems to the system. While tracking `mount` commands gives the system administrator evidence that external media may have been mounted (based on a review of the source of the mount and confirming it's an external media type), it does not conclusively indicate that data was exported to the media. System administrators who wish to determine if data were exported, would also have to track successful `open`, `creat` and `truncate` system calls requiring write access to a file under the mount point of the external media file system. This could give a fair indication that a write occurred. The only way to truly prove it, would be to track successful writes to the external media. Tracking write system calls could quickly fill up the audit log and is not recommended. Recommendations on configuration options to track data export to media is beyond the scope of this document."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.10_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor successful file system mounts.\n\n_Example:_\n\n```\n# {\nUID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n[ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F arch=b32 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts\n-a always,exit -F arch=b64 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts\n\" >> /etc/audit/rules.d/50-mounts.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.10_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -S/ \\\n &&/mount/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=unset -k mounts\n-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=unset -k mounts\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -S/ \\\n &&/mount/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=-1 -F key=mounts\n-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=-1 -F key=mounts\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.11",
                    "title": "Ensure session initiation information is collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.11"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.11_statement",
                        "prose": "Monitor session initiation events. The parameters in this section track changes to the files associated with session events.\n- `/var/run/utmp` - tracks all currently logged in users.\n- `/var/log/wtmp` - file tracks logins, logouts, shutdown, and reboot events.\n- `/var/log/btmp` - keeps track of failed login attempts and can be read by entering the command `/usr/bin/last -f /var/log/btmp`.\n\nAll audit records will be tagged with the identifier \"session.\""
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.11_assessment-objective",
                        "prose": "Rationale: Monitoring these files for changes could alert a system administrator to logins occurring at unusual hours, which could indicate intruder activity (i.e. a user logging in at a time when they do not normally log in)."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.11_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor session initiation information.\n\n_Example:_\n\n```\n# printf \"\n-w /var/run/utmp -p wa -k session\n-w /var/log/wtmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n\" >> /etc/audit/rules.d/50-session.rules\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.11_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-w/ \\\n&&(/\\/var\\/run\\/utmp/ \\\n ||/\\/var\\/log\\/wtmp/ \\\n ||/\\/var\\/log\\/btmp/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-w /var/run/utmp -p wa -k session\n-w /var/log/wtmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-w/ \\\n&&(/\\/var\\/run\\/utmp/ \\\n ||/\\/var\\/log\\/wtmp/ \\\n ||/\\/var\\/log\\/btmp/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-w /var/run/utmp -p wa -k session\n-w /var/log/wtmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.12",
                    "title": "Ensure login and logout events are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.12"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.12_statement",
                        "prose": "Monitor login and logout events. The parameters below track changes to files associated with login/logout events.\n- `/var/log/lastlog` - maintain records of the last time a user successfully logged in. \n- `/var/run/faillock` - directory maintains records of login failures via the `pam_faillock` module."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.12_assessment-objective",
                        "prose": "Rationale: Monitoring login/logout events could provide a system administrator with information associated with brute force attacks against user logins."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.12_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor login and logout events.\n\n_Example:_\n\n```\n# printf \"\n-w /var/log/lastlog -p wa -k logins\n-w /var/run/faillock -p wa -k logins\n\" >> /etc/audit/rules.d/50-login.rules\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.12_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-w/ \\\n&&(/\\/var\\/log\\/lastlog/ \\\n ||/\\/var\\/run\\/faillock/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-w /var/log/lastlog -p wa -k logins\n-w /var/run/faillock -p wa -k logins\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-w/ \\\n&&(/\\/var\\/log\\/lastlog/ \\\n ||/\\/var\\/run\\/faillock/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-w /var/log/lastlog -p wa -k logins\n-w /var/run/faillock -p wa -k logins\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.13",
                    "title": "Ensure file deletion events by users are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.13"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.13_statement",
                        "prose": "Monitor the use of system calls associated with the deletion or renaming of files and file attributes. This configuration statement sets up monitoring for:\n- `unlink` - remove a file\n- `unlinkat` - remove a file attribute\n- `rename` - rename a file\n- `renameat` rename a file attribute\nsystem calls and tags them with the identifier \"delete\"."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.13_assessment-objective",
                        "prose": "Rationale: Monitoring these calls from non-privileged users could provide a system administrator with evidence that inappropriate removal of files and file attributes associated with protected files is occurring. While this audit option will look at all events, system administrators will want to look for specific privileged files that are being deleted or altered."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.13_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor file deletion events by users.\n\n_Example:_\n\n```\n# {\nUID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n[ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete\n-a always,exit -F arch=b32 -S rename,unlink,unlinkat,renameat -F auid>=${UID_MIN} -F auid!=unset -F key=delete\n\" >> /etc/audit/rules.d/50-delete.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.13_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -S/ \\\n &&(/unlink/||/rename/||/unlinkat/||/renameat/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k delete\n-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F auid>=1000 -F auid!=unset -k delete\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -S/ \\\n &&(/unlink/||/rename/||/unlinkat/||/renameat/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S rename,unlink,unlinkat,renameat -F auid>=1000 -F auid!=-1 -F key=delete\n-a always,exit -F arch=b32 -S unlink,rename,unlinkat,renameat -F auid>=1000 -F auid!=-1 -F key=delete\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.14",
                    "title": "Ensure events that modify the system's Mandatory Access Controls are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.14"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.14_statement",
                        "prose": "Monitor SELinux, an implementation of mandatory access controls. The parameters below monitor any write access (potential additional, deletion or modification of files in the directory) or attribute changes to the `/etc/selinux/` and `/usr/share/selinux/` directories.\n\n**Note:** If a different Mandatory Access Control method is used, changes to the corresponding directories should be audited."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.14_assessment-objective",
                        "prose": "Rationale: Changes to files in the `/etc/selinux/` and `/usr/share/selinux/` directories could indicate that an unauthorized user is attempting to modify access controls and change security contexts, leading to a compromise of the system."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.14_guidance",
                        "prose": "Edit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor events that modify the system's Mandatory Access Controls.\n\n_Example:_\n\n```\n# printf \"\n-w /etc/selinux -p wa -k MAC-policy\n-w /usr/share/selinux -p wa -k MAC-policy\n\" >> /etc/audit/rules.d/50-MAC-policy.rules\n```\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.14_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# awk '/^ *-w/ \\\n&&(/\\/etc\\/selinux/ \\\n ||/\\/usr\\/share\\/selinux/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n```\n\nVerify the output matches:\n\n```\n-w /etc/selinux -p wa -k MAC-policy\n-w /usr/share/selinux -p wa -k MAC-policy\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# auditctl -l | awk '/^ *-w/ \\\n&&(/\\/etc\\/selinux/ \\\n ||/\\/usr\\/share\\/selinux/) \\\n&&/ +-p *wa/ \\\n&&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n```\n\nVerify the output matches:\n\n```\n-w /etc/selinux -p wa -k MAC-policy\n-w /usr/share/selinux -p wa -k MAC-policy\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.15",
                    "title": "Ensure successful and unsuccessful attempts to use the chcon command are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.15"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.15_statement",
                        "prose": "The operating system must generate audit records for successful/unsuccessful uses of the `chcon` command."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.15_assessment-objective",
                        "prose": "Rationale: The `chcon` command is used to change file security context. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nAudit records can be generated from various components within the information system (e.g., module or policy filter)."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.15_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor successful and unsuccessful attempts to use the `chcon` command.\n\n_Example:_\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng\n\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.15_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/chcon/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/chcon/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -S all -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=-1 -F key=perm_chng\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.16",
                    "title": "Ensure successful and unsuccessful attempts to use the setfacl command are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.16"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.16_statement",
                        "prose": "The operating system must generate audit records for successful/unsuccessful uses of the `setfacl` command"
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.16_assessment-objective",
                        "prose": "Rationale: This utility sets Access Control Lists (ACLs) of files and directories. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nAudit records can be generated from various components within the information system (e.g., module or policy filter)."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.16_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor successful and unsuccessful attempts to use the `setfacl` command.\n\n_Example:_\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng\n\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.16_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/setfacl/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/setfacl/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -S all -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=-1 -F key=perm_chng\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.17",
                    "title": "Ensure successful and unsuccessful attempts to use the chacl command are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.17"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.17_statement",
                        "prose": "The operating system must generate audit records for successful/unsuccessful uses of the `chacl` command.\n\n`chacl` is an IRIX-compatibility command, and is maintained for those users who are familiar with its use from either XFS or IRIX."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.17_assessment-objective",
                        "prose": "Rationale: `chacl` changes the ACL(s) for a file or directory. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nAudit records can be generated from various components within the information system (e.g., module or policy filter)."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.17_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor successful and unsuccessful attempts to use the `chacl` command.\n\n_Example:_\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k perm_chng\n\" >> /etc/audit/rules.d/50-perm_chng.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.17_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/chacl/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -k perm_chng\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/chacl/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -S all -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=-1 -F key=perm_chng\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.18",
                    "title": "Ensure successful and unsuccessful attempts to use the usermod command are collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.18"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.18_statement",
                        "prose": "The operating system must generate audit records for successful/unsuccessful uses of the `usermod` command."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.18_assessment-objective",
                        "prose": "Rationale: The `usermod` command modifies the system account files to reflect the changes that are specified on the command line. Without generating audit records that are specific to the security and mission needs of the organization, it would be difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one. \n\nAudit records can be generated from various components within the information system (e.g., module or policy filter)."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.18_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor successful and unsuccessful attempts to use the `usermod` command.\n\n_Example:_\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && printf \"\n-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k usermod\n\" >> /etc/audit/rules.d/50-usermod.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.18_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following command to check the on disk rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/sbin\\/usermod/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -k usermod\n```\n\n**Running configuration**\n\nRun the following command to check loaded rules:\n\n```\n# {\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/sbin\\/usermod/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -S all -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=-1 -F key=usermod\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.19",
                    "title": "Ensure kernel module loading unloading and modification is collected",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.19"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.19_statement",
                        "prose": "Monitor the loading and unloading of kernel modules. All the loading / listing / dependency checking of modules is done by `kmod` via symbolic links.\n\nThe following system calls control loading and unloading of modules:\n- `init_module` - load a module\n- `finit_module` - load a module (used when the overhead of using cryptographically signed modules to determine the authenticity of a module can be avoided)\n- `delete_module` - delete a module\n- `create_module` - create a loadable module entry\n- `query_module` - query the kernel for various bits pertaining to modules\n\nAny execution of the loading and unloading module programs and system calls will trigger an audit record with an identifier of `modules`."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.19_assessment-objective",
                        "prose": "Rationale: Monitoring the use of all the various ways to manipulate kernel modules could provide system administrators with evidence that an unauthorized change was made to a kernel module, possibly compromising the security of the system."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.19_guidance",
                        "prose": "**Create audit rules**\n\nEdit or create a file in the `/etc/audit/rules.d/` directory, ending in `.rules` extension, with the relevant rules to monitor kernel module modification.\n\n_Example:_\n\n```\n#!/usr/bin/env bash\n\n{\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && printf \"\n -a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules\n -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k kernel_modules\n \" >> /etc/audit/rules.d/50-kernel_modules.rules || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.19_assessment-method",
                        "prose": "**On disk configuration**\n\nRun the following script to check the on disk rules:\n\n```\n#!/usr/bin/env bash\n\n{\n awk '/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\\n &&/ -S/ \\\n &&(/init_module/ \\\n ||/finit_module/ \\\n ||/delete_module/ \\\n ||/create_module/ \\\n ||/query_module/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)' /etc/audit/rules.d/*.rules\n\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/kmod/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" /etc/audit/rules.d/*.rules \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output matches:\n\n```\n-a always,exit -F arch=b64 -S init_module,finit_module,delete_module,create_module,query_module -F auid>=1000 -F auid!=unset -k kernel_modules\n-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -k kernel_modules\n```\n\n**Running configuration**\n\nRun the following script to check loaded rules:\n\n```\n#!/usr/bin/env bash\n\n{\n auditctl -l | awk '/^ *-a *always,exit/ \\\n &&/ -F *arch=b(32|64)/ \\\n &&(/ -F auid!=unset/||/ -F auid!=-1/||/ -F auid!=4294967295/) \\\n &&/ -S/ \\\n &&(/init_module/ \\\n ||/finit_module/ \\\n ||/delete_module/ \\\n ||/create_module/ \\\n ||/query_module/) \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)'\n\n UID_MIN=$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\n [ -n \"${UID_MIN}\" ] && auditctl -l | awk \"/^ *-a *always,exit/ \\\n &&(/ -F *auid!=unset/||/ -F *auid!=-1/||/ -F *auid!=4294967295/) \\\n &&/ -F *auid>=${UID_MIN}/ \\\n &&/ -F *perm=x/ \\\n &&/ -F *path=\\/usr\\/bin\\/kmod/ \\\n &&(/ key= *[!-~]* *$/||/ -k *[!-~]* *$/)\" \\\n || printf \"ERROR: Variable 'UID_MIN' is unset.\\n\"\n}\n```\n\nVerify the output includes:\n\n```\n-a always,exit -F arch=b64 -S create_module,init_module,delete_module,query_module,finit_module -F auid>=1000 -F auid!=-1 -F key=kernel_modules\n-a always,exit -S all -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=-1 -F key=kernel_modules\n```\n\n**Symlink audit**\n\nRun the following script to audit if the symlinks `kmod` accepts are indeed pointing at it:\n\n```\n#!/usr/bin/env bash\n\n{\n a_files=(\"/usr/sbin/lsmod\" \"/usr/sbin/rmmod\" \"/usr/sbin/insmod\" \"/usr/sbin/modinfo\" \"/usr/sbin/modprobe\" \"/usr/sbin/depmod\")\n for l_file in \"${a_files[@]}\"; do\n if [ \"$(readlink -f \"$l_file\")\" = \"$(readlink -f /bin/kmod)\" ]; then\n printf \"OK: \\\"$l_file\\\"\\n\"\n else\n printf \"Issue with symlink for file: \\\"$l_file\\\"\\n\"\n fi\n done\n}\n```\n\nVerify the output states `OK`. If there is a symlink pointing to a different location it should be investigated",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.20",
                    "title": "Ensure the audit configuration is immutable",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.20"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.20_statement",
                        "prose": "Set system audit so that audit rules cannot be modified with `auditctl` . Setting the flag \"-e 2\" forces audit to be put in immutable mode. Audit changes can only be made on system reboot.\n\n**Note:** This setting will require the system to be rebooted to update the active `auditd` configuration settings."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.20_assessment-objective",
                        "prose": "Rationale: In immutable mode, unauthorized users cannot execute changes to the audit system to potentially hide malicious activity and then put the audit rules back. Users would most likely notice a system reboot and that could alert administrators of an attempt to make unauthorized audit changes."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.20_guidance",
                        "prose": "Edit or create the file `/etc/audit/rules.d/99-finalize.rules` and add the line `-e 2` at the end of the file:\n\n_Example:_ \n\n```\n# printf '\\n%s' \"-e 2\" >> /etc/audit/rules.d/99-finalize.rules\n```\n\n**Load audit rules**\n\nMerge and load the rules into active configuration:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\n# if [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then printf \"Reboot required to load rules\\n\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.20_assessment-method",
                        "prose": "Run the following command and verify output matches:\n\n```\n# grep -Ph -- '^\\h*-e\\h+2\\b' /etc/audit/rules.d/*.rules | tail -1\n\n-e 2\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.3.21",
                    "title": "Ensure the running and on disk configuration is the same",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.3.21"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.3.21_statement",
                        "prose": "The Audit system have both on disk and running configuration. It is possible for these configuration settings to differ.\n\n**Note:** Due to the limitations of `augenrules` and `auditctl`, it is not absolutely guaranteed that loading the rule sets via `augenrules --load` will result in all rules being loaded or even that the user will be informed if there was a problem loading the rules."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.3.21_assessment-objective",
                        "prose": "Rationale: Configuration differences between what is currently running and what is on disk could cause unexpected problems or may give a false impression of compliance requirements."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.3.21_guidance",
                        "prose": "If the rules are not aligned across all three () areas, run the following command to merge and load all rules:\n\n```\n# augenrules --load\n```\n\nCheck if reboot is required.\n\n```\nif [[ $(auditctl -s | grep \"enabled\") =~ \"2\" ]]; then echo \"Reboot required to load rules\"; fi\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.3.21_assessment-method",
                        "prose": "**Merged rule sets**\n\nEnsure that all rules in `/etc/audit/rules.d` have been merged into `/etc/audit/audit.rules`:\n\n```\n# augenrules --check\n\n/usr/sbin/augenrules: No change\n```\n\nShould there be any drift, run `augenrules --load` to merge and load all rules.",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              },
              {
                "id": "section-6-3-4",
                "title": "Configure auditd File Access",
                "props": [
                  {
                    "name": "label",
                    "value": "6.3.4"
                  }
                ],
                "controls": [
                  {
                    "id": "cis-6.3.4.1",
                    "title": "Ensure the audit log file directory mode is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.1"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.1_statement",
                        "prose": "The audit log directory contains audit log files."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.1_assessment-objective",
                        "prose": "Rationale: Audit information includes all information including: audit records, audit settings and audit reports. This information is needed to successfully audit system activity. This information must be protected from unauthorized modification or deletion. If this information were to be compromised, forensic analysis and discovery of the true source of potentially malicious system activity is impossible to achieve."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.1_guidance",
                        "prose": "Run the following command to configure the audit log directory to have a mode of \"0750\" or less permissive: \n\n```\n# chmod g-w,o-rwx \"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.1_assessment-method",
                        "prose": "Run the following script to verify the audit log directory is mode 0750 or more restrictive:\n\n```\n#!/usr/bin/env bash\n\n{\n l_perm_mask=\"0027\"\n if [ -e \"/etc/audit/auditd.conf\" ]; then\n l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"\n if [ -d \"$l_audit_log_directory\" ]; then\n l_maxperm=\"$(printf '%o' $(( 0777 & ~$l_perm_mask )) )\"\n l_directory_mode=\"$(stat -Lc '%#a' \"$l_audit_log_directory\")\"\n if [ $(( $l_directory_mode & $l_perm_mask )) -gt 0 ]; then\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - Directory: \\\"$l_audit_log_directory\\\" is mode: \\\"$l_directory_mode\\\"\\n (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"\n else\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - Directory: \\\"$l_audit_log_directory\\\" is mode: \\\"$l_directory_mode\\\"\\n (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"\n fi \n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"\n fi\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - File: \\\"/etc/audit/auditd.conf\\\" not found\\n - ** Verify auditd is installed **\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.2",
                    "title": "Ensure audit log files mode is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.2"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.2_statement",
                        "prose": "Audit log files contain information about the system and system activity."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.2_assessment-objective",
                        "prose": "Rationale: Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.2_guidance",
                        "prose": "Run the following command to remove more permissive mode than `0640` from audit log files:\n\n```\n# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f -perm /0137 -exec chmod u-x,g-wx,o-rwx {} +\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.2_assessment-method",
                        "prose": "Run the following script to verify audit log files are mode `0640` or more restrictive:\n\n```\n#!/usr/bin/env bash\n\n{\n l_output=\"\" l_output2=\"\"\n l_perm_mask=\"0177\"\n if [ -e \"/etc/audit/auditd.conf\" ]; then\n l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"\n if [ -d \"$l_audit_log_directory\" ]; then\n l_maxperm=\"$(printf '%o' $(( 0777 & ~$l_perm_mask )) )\"\n while IFS= read -r -d $'\\0' l_file; do\n while IFS=: read -r l_file_mode l_hr_file_mode; do\n l_output2=\"$l_output2\\n - File: \\\"$l_file\\\" is mode: \\\"$l_file_mode\\\"\\n (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"\n done <<< \"$(stat -Lc '%#a:%A' \"$l_file\")\"\n done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f -perm /\"$l_perm_mask\" -print0)\n else\n l_output2=\"$l_output2\\n - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"\n fi\n else\n l_output2=\"$l_output2\\n - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n - ** Verify auditd is installed **\"\n fi\n if [ -z \"$l_output2\" ]; then\n l_output=\"$l_output\\n - All files in \\\"$l_audit_log_directory\\\" are mode: \\\"$l_maxperm\\\" or more restrictive\"\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - * Correctly configured * :$l_output\"\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.3",
                    "title": "Ensure audit log files owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.3"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.3_statement",
                        "prose": "Audit log files contain information about the system and system activity."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.3_assessment-objective",
                        "prose": "Rationale: Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.3_guidance",
                        "prose": "Run the following command to configure the audit log files to be owned by the `root` user: \n\n```\n# [ -f /etc/audit/auditd.conf ] && find \"$(dirname $(awk -F \"=\" '/^\\s*log_file/ {print $2}' /etc/audit/auditd.conf | xargs))\" -type f ! -user root -exec chown root {} +\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.3_assessment-method",
                        "prose": "Run the following script to verify audit log files are owned by the `root` user: \n\n```\n#!/usr/bin/env bash\n\n{\n l_output=\"\" l_output2=\"\"\n l_perm_mask=\"0177\"\n if [ -e \"/etc/audit/auditd.conf\" ]; then\n l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"\n if [ -d \"$l_audit_log_directory\" ]; then\n l_maxperm=\"$(printf '%o' $(( 0777 & ~$l_perm_mask )) )\"\n while IFS= read -r -d $'\\0' l_file; do\n l_output2=\"$l_output2\\n - File: \\\"$l_file\\\" is mode: \\\"$(stat -Lc '%#a' \"$l_file\")\\\"\\n (should be mode: \\\"$l_maxperm\\\" or more restrictive)\\n\"\n done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f -perm /\"$l_perm_mask\" -print0)\n else\n l_output2=\"$l_output2\\n - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"\n fi\n else\n l_output2=\"$l_output2\\n - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n - ** Verify auditd is installed **\"\n fi\n if [ -z \"$l_output2\" ]; then\n l_output=\"$l_output\\n - All files in \\\"$l_audit_log_directory\\\" are mode: \\\"$l_maxperm\\\" or more restrictive\"\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - * Correctly configured * :$l_output\"\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.4",
                    "title": "Ensure audit log files group owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.4"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.4_statement",
                        "prose": "Audit log files contain information about the system and system activity."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.4_assessment-objective",
                        "prose": "Rationale: Access to audit records can reveal system and configuration data to attackers, potentially compromising its confidentiality."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.4_guidance",
                        "prose": "Run the following command to configure the audit log files to be owned by `adm` group: \n\n```\n# find $(dirname $(awk -F\"=\" '/^\\s*log_file\\s*=\\s*/ {print $2}' /etc/audit/auditd.conf | xargs)) -type f \\( ! -group adm -a ! -group root \\) -exec chgrp adm {} +\n```\n\nRun the following command to configure the audit log files to be owned by the `adm` group:\n\n```\n# chgrp adm /var/log/audit/\n```\n\nRun the following command to set the `log_group` parameter in the audit configuration file to `log_group = adm`:\n\n```\n# sed -ri 's/^\\s*#?\\s*log_group\\s*=\\s*\\S+(\\s*#.*)?.*$/log_group = adm\\1/' /etc/audit/auditd.conf\n```\n\nRun the following command to restart the audit daemon to reload the configuration file: \n\n```\n# systemctl restart auditd\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.4_assessment-method",
                        "prose": "Run the following script to verify:\n- `log_group` parameter is set to either `adm` or `root` in `/etc/audit/auditd.conf`\n- audit log files are group owned by the group \"root\" or \"adm\" \n\n```\n#!/usr/bin/env bash\n\n{\n l_output=\"\" l_output2=\"\"\n if [ -e \"/etc/audit/auditd.conf\" ]; then\n l_audit_log_directory=\"$(dirname \"$(awk -F= '/^\\s*log_file\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\")\"\n l_audit_log_group=\"$(awk -F= '/^\\s*log_group\\s*/{print $2}' /etc/audit/auditd.conf | xargs)\"\n if grep -Pq -- '^\\h*(root|adm)\\h*$' <<< \"$l_audit_log_group\"; then\n l_output=\"$l_output\\n - Log file group correctly set to: \\\"$l_audit_log_group\\\" in \\\"/etc/audit/auditd.conf\\\"\"\n else\n l_output2=\"$l_output2\\n - Log file group is set to: \\\"$l_audit_log_group\\\" in \\\"/etc/audit/auditd.conf\\\"\\n (should be set to group: \\\"root or adm\\\")\\n\"\n fi\n if [ -d \"$l_audit_log_directory\" ]; then\n while IFS= read -r -d $'\\0' l_file; do\n l_output2=\"$l_output2\\n - File: \\\"$l_file\\\" is group owned by group: \\\"$(stat -Lc '%G' \"$l_file\")\\\"\\n (should be group owned by group: \\\"root or adm\\\")\\n\"\n done < <(find \"$l_audit_log_directory\" -maxdepth 1 -type f \\( ! -group root -a ! -group adm \\) -print0)\n else\n l_output2=\"$l_output2\\n - Log file directory not set in \\\"/etc/audit/auditd.conf\\\" please set log file directory\"\n fi\n else\n l_output2=\"$l_output2\\n - File: \\\"/etc/audit/auditd.conf\\\" not found.\\n - ** Verify auditd is installed **\"\n fi\n if [ -z \"$l_output2\" ]; then\n l_output=\"$l_output\\n - All files in \\\"$l_audit_log_directory\\\" are group owned by group: \\\"root or adm\\\"\\n\"\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - * Correctly configured * :$l_output\"\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"\n [ -n \"$l_output\" ] && echo -e \" - * Correctly configured * :\\n$l_output\\n\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.5",
                    "title": "Ensure audit configuration files mode is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.5"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.5_statement",
                        "prose": "Audit configuration files control auditd and what events are audited."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.5_assessment-objective",
                        "prose": "Rationale: Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events. \n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.5_guidance",
                        "prose": "Run the following command to remove more permissive mode than 0640 from the audit configuration files:\n\n```\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) -exec chmod u-x,g-wx,o-rwx {} +\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.5_assessment-method",
                        "prose": "Run the following script to verify that the audit configuration files are mode `0640` or more restrictive:\n\n```\n#!/usr/bin/env bash\n\n{\n l_output=\"\" l_output2=\"\" l_perm_mask=\"0137\"\n l_maxperm=\"$( printf '%o' $(( 0777 & ~$l_perm_mask )) )\"\n while IFS= read -r -d $'\\0' l_fname; do\n l_mode=$(stat -Lc '%#a' \"$l_fname\")\n if [ $(( \"$l_mode\" & \"$l_perm_mask\" )) -gt 0 ]; then\n l_output2=\"$l_output2\\n - file: \\\"$l_fname\\\" is mode: \\\"$l_mode\\\" (should be mode: \\\"$l_maxperm\\\" or more restrictive)\"\n fi\n done < <(find /etc/audit/ -type f \\( -name \"*.conf\" -o -name '*.rules' \\) -print0)\n if [ -z \"$l_output2\" ]; then\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - All audit configuration files are mode: \\\"$l_maxperm\\\" or more restrictive\"\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n$l_output2\"\n fi\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.6",
                    "title": "Ensure audit configuration files owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.6"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.6_statement",
                        "prose": "Audit configuration files control auditd and what events are audited."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.6_assessment-objective",
                        "prose": "Rationale: Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events. \n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.6_guidance",
                        "prose": "Run the following command to change ownership to `root` user:\n\n```\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -user root -exec chown root {} +\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.6_assessment-method",
                        "prose": "Run the following command to verify that the audit configuration files have mode 640 or more restrictive and are owned by the root user and root group: \n\n```\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -user root\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.7",
                    "title": "Ensure audit configuration files group owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.7"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.7_statement",
                        "prose": "Audit configuration files control auditd and what events are audited."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.7_assessment-objective",
                        "prose": "Rationale: Access to the audit configuration files could allow unauthorized personnel to prevent the auditing of critical events. \n\nMisconfigured audit configuration files may prevent the auditing of critical events or impact the system's performance by overwhelming the audit log. Misconfiguration of the audit configuration files may also make it more difficult to establish and investigate events relating to an incident."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.7_guidance",
                        "prose": "Run the following command to change group to `root`:\n\n```\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -group root -exec chgrp root {} +\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.7_assessment-method",
                        "prose": "Run the following command to verify that the audit configuration files are owned by the group `root`: \n\n```\n# find /etc/audit/ -type f \\( -name '*.conf' -o -name '*.rules' \\) ! -group root\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.8",
                    "title": "Ensure audit tools mode is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.8"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.8_statement",
                        "prose": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.8_assessment-objective",
                        "prose": "Rationale: Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.8_guidance",
                        "prose": "Run the following command to remove more permissive mode from the audit tools: \n\n```\n# chmod go-w /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.8_assessment-method",
                        "prose": "Run the following script to verify the audit tools are mode `0755` or more restrictive:\n\n```\n#!/usr/bin/env bash\n\n{\n l_output=\"\" l_output2=\"\" l_perm_mask=\"0022\"\n l_maxperm=\"$( printf '%o' $(( 0777 & ~$l_perm_mask )) )\"\n a_audit_tools=(\"/sbin/auditctl\" \"/sbin/aureport\" \"/sbin/ausearch\" \"/sbin/autrace\" \"/sbin/auditd\" \"/sbin/augenrules\")\n for l_audit_tool in \"${a_audit_tools[@]}\"; do\n l_mode=\"$(stat -Lc '%#a' \"$l_audit_tool\")\"\n if [ $(( \"$l_mode\" & \"$l_perm_mask\" )) -gt 0 ]; then\n l_output2=\"$l_output2\\n - Audit tool \\\"$l_audit_tool\\\" is mode: \\\"$l_mode\\\" and should be mode: \\\"$l_maxperm\\\" or more restrictive\"\n else\n l_output=\"$l_output\\n - Audit tool \\\"$l_audit_tool\\\" is correctly configured to mode: \\\"$l_mode\\\"\"\n fi\n done\n if [ -z \"$l_output2\" ]; then\n echo -e \"\\n- Audit Result:\\n ** PASS **\\n - * Correctly configured * :$l_output\"\n else\n echo -e \"\\n- Audit Result:\\n ** FAIL **\\n - * Reasons for audit failure * :$l_output2\\n\"\n [ -n \"$l_output\" ] && echo -e \"\\n - * Correctly configured * :\\n$l_output\\n\"\n fi\n unset a_audit_tools\n}\n```",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.9",
                    "title": "Ensure audit tools owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.9"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.9_statement",
                        "prose": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.9_assessment-objective",
                        "prose": "Rationale: Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.9_guidance",
                        "prose": "Run the following command to change the owner of the audit tools to the `root` user:\n\n```\n# chown root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.9_assessment-method",
                        "prose": "Run the following command to verify the audit tools are owned by the `root` user: \n\n```\n# stat -Lc \"%n %U\" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | awk '$2 != \"root\" {print}'\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "cis-6.3.4.10",
                    "title": "Ensure audit tools group owner is configured",
                    "props": [
                      {
                        "name": "label",
                        "value": "6.3.4.10"
                      }
                    ],
                    "parts": [
                      {
                        "name": "statement",
                        "id": "cis-6.3.4.10_statement",
                        "prose": "Audit tools include, but are not limited to, vendor-provided and open source audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators."
                      },
                      {
                        "name": "assessment-objective",
                        "id": "cis-6.3.4.10_assessment-objective",
                        "prose": "Rationale: Protecting audit information includes identifying and protecting the tools used to view and manipulate log data. Protecting audit tools is necessary to prevent unauthorized operation on audit information."
                      },
                      {
                        "name": "guidance",
                        "id": "cis-6.3.4.10_guidance",
                        "prose": "Run the following command to change group ownership to the groop `root`:\n\n```\n# chgrp root /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules\n```"
                      },
                      {
                        "name": "assessment-method",
                        "id": "cis-6.3.4.10_assessment-method",
                        "prose": "Run the following command to verify the audit tools are owned by the group `root`\n\n```\n# stat -Lc \"%n %G\" /sbin/auditctl /sbin/aureport /sbin/ausearch /sbin/autrace /sbin/auditd /sbin/augenrules | awk '$2 != \"root\" {print}'\n```\n\nNothing should be returned",
                        "props": [
                          {
                            "name": "method",
                            "value": "TEST",
                            "ns": "http://csrc.nist.gov/ns/rmf"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "groups": []
              }
            ]
          }
        ]
      },
      {
        "id": "section-7",
        "title": "System Maintenance",
        "props": [
          {
            "name": "label",
            "value": "7"
          }
        ],
        "controls": [],
        "groups": [
          {
            "id": "section-7-1",
            "title": "System File Permissions",
            "props": [
              {
                "name": "label",
                "value": "7.1"
              }
            ],
            "controls": [],
            "groups": []
          },
          {
            "id": "section-7-2",
            "title": "Local User and Group Settings",
            "props": [
              {
                "name": "label",
                "value": "7.2"
              }
            ],
            "controls": [],
            "groups": []
          }
        ]
      }
    ],
    "back-matter": {
      "resources": [
        {
          "uuid": "17875565-63da-4265-ac99-39617f0481ca",
          "title": "CIS AlmaLinux OS 9 Benchmark v1.0.0 - Certification",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/4229/download"
            }
          ]
        },
        {
          "uuid": "1c252644-2556-490a-af88-0aa90d6d965e",
          "title": "CIS AlmaLinux OS 9 Benchmark v1.0.0 - Excel",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/4228/download"
            }
          ]
        },
        {
          "uuid": "0416a9ec-2ae8-45d7-82e3-bd136d4e040f",
          "title": "CIS AlmaLinux OS 9 Benchmark v1.0.0 - Word",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/4227/download"
            }
          ]
        },
        {
          "uuid": "ec070426-9645-4980-a44f-ae2b01076d70",
          "title": "CIS AlmaLinux OS 9 Benchmark v1.0.0 - PDF",
          "citation": {
            "text": "This document provides prescriptive guidance for establishing a secure configuration posture for AlmaLinux OS 9 systems running on x86_64 platforms."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/4226/download"
            }
          ]
        },
        {
          "uuid": "f854fee7-ef29-4b4b-ae86-f3fd32bf99be",
          "title": "CIS AlmaLinux OS 9 Benchmark v2.0.0 - Certification",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/5428/download"
            }
          ]
        },
        {
          "uuid": "06ad8ed0-735d-4aaf-a058-298d0e1e60cf",
          "title": "CIS AlmaLinux OS 9 Benchmark v2.0.0 - Build Kit",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/5525/download"
            }
          ]
        },
        {
          "uuid": "a7e5c594-1c94-47e3-bfb4-6977dcc704a1",
          "title": "CIS AlmaLinux OS 9 Benchmark v2.0.0 - Excel",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/5427/download"
            }
          ]
        },
        {
          "uuid": "cbbde88b-e14e-40c2-8a1a-c96a4718f0b5",
          "title": "CIS AlmaLinux OS 9 Benchmark v2.0.0 - Word",
          "citation": {
            "text": "The Word and Excel versions of the CIS Benchmarks, as well as Build Kits, are available for use internally by our members and not intended to be distributed outside of the member organization. The Word and Excel versions, like that of the PDF versions, are governed by the CIS Terms and Conditions (Terms and Conditions Table of Contents (cisecurity.org)) as well as WorkBench Terms of Use (CIS WorkBench / Terms of Use (cisecurity.org))."
          },
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/5426/download"
            }
          ]
        },
        {
          "uuid": "9f6eafb6-d1c4-4df3-8a62-cfb0de5cc517",
          "title": "CIS AlmaLinux OS 9 Benchmark v2.0.0 - PDF",
          "rlinks": [
            {
              "href": "https://workbench.cisecurity.org/files/5425/download"
            }
          ]
        }
      ]
    }
  }
}